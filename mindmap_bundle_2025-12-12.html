<html lang="en"><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mind Mapper - 12/9/2025</title>
    <!-- Google Fonts for better typography -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&amp;family=Nunito:wght@400;600;700&amp;family=Open+Sans:wght@400;600&amp;family=Poppins:wght@400;500;600&amp;display=swap" rel="stylesheet">
    <style>
        /* Global body styling with modern font stack */
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, sans-serif;
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevents scrollbars */
            background-color: #f0f2f5; /* Light gray background */
        }
        
        /* Loading screen that shows while fonts are loading */
        #loadingIndicator {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; display: flex;
            justify-content: center; align-items: center; font-size: 2em;
            background-color: #f0f2f5; z-index: 9999; color: #555;
        }
        
        /* Canvas styling with different cursor states */
        #canvas { display: block; background-color: #ffffff; cursor: grab; z-index: 1; }
        #canvas.connecting { cursor: crosshair; } /* When connecting bubbles */
        #canvas:active { cursor: grabbing; } /* When dragging */
        
        /* Control panel styling - floating toolbar at top-left */
        #controls {
            position: absolute; top: 10px; left: 10px; background-color: rgba(255, 255, 255, 0.9);
            padding: 10px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            display: flex; flex-wrap: wrap; gap: 10px; align-items: center; max-width: calc(100% - 80px);
        }
        
        /* Instruction text in control panel */
        #controls span {
            font-size: 12px;
            color: #555;
            padding-left: 10px;
            border-left: 2px solid #eee;
        }
        
        /* Button styling for all interactive elements */
        button {
            padding: 8px 12px; border-radius: 6px; border: 1px solid #ccc;
            background-color: #fff; cursor: pointer; font-size: 14px; font-family: 'Inter', sans-serif;
            position: relative; /* Ensure tooltips work properly */
        }
        button:hover { background-color: #f0f0f0; }
        button:disabled { background-color: #f8f8f8; color: #aaa; cursor: not-allowed; }
        
        /* Ensure Load button tooltip works properly */
        #loadBtn {
            z-index: 10; /* Ensure it's above the hidden file input */
        }
        
        /* Hide file input but keep it functional */
        input[type="file"] { 
            display: none; 
            pointer-events: none; /* Prevent interference with tooltips */
        }
        
        /* Context menu styling - appears on right-click */
        #contextMenu {
            position: absolute; display: none; background-color: #fff; border: 1px solid #ccc;
            border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            padding: 6px 0; min-width: 200px; z-index: 1000;
        }
        #contextMenu button { text-align: left; }
        
        /* Help button - floating blue circle in top-right */
        #helpBtn {
            position: absolute; top: 10px; right: 10px; width: 40px; height: 40px;
            border-radius: 50%; background-color: #007bff; color: white; border: none;
            font-size: 24px; font-weight: bold; cursor: pointer; display: flex;
            align-items: center; justify-content: center; box-shadow: 0 2px 8px rgba(0,0,0,0.2); z-index: 1001;
        }
        
        /* Modal overlay styling for help and comment dialogs */
        #helpModal, #commentModal {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.5); z-index: 2000; justify-content: center; align-items: center;
        }
        
        /* Modal content styling */
        .modal-content {
            background-color: #fff; padding: 30px; border-radius: 10px; max-width: 500px;
            width: 90%; box-shadow: 0 5px 15px rgba(0,0,0,0.3); font-family: 'Nunito', sans-serif;
        }
        .modal-content h2 { margin-top: 0; font-family: 'Open Sans', sans-serif; }
        .modal-content ul { padding-left: 20px; }
        
        /* Keyboard shortcut styling */
        .modal-content kbd {
            background-color: #eee; border-radius: 3px; border: 1px solid #b4b4b4;
            padding: 2px 4px; font-family: monospace;
        }
        
        /* Comment display area with scroll */
        #commentDisplay { white-space: pre-wrap; max-height: 60vh; overflow-y: auto; }
        
        /* Color palette for bubble colors */
        #colorPalette { display: flex; gap: 5px; border-left: 2px solid #eee; padding-left: 10px; }
        .color-swatch {
            width: 24px; height: 24px; border-radius: 50%; cursor: pointer;
            border: 2px solid transparent; transition: transform 0.1s;
        }
        .color-swatch:hover { transform: scale(1.1); }
        .color-swatch.selected { border-color: #333; }
        
        /* Text input for creating new bubbles */
        #textInput {
            position: absolute;
            display: none;
            border: 1px dashed #999;
            background-color: rgba(255, 255, 255, 0.8);
            font-family: 'Inter', sans-serif;
            font-size: 16px;
            padding: 10px;
            box-sizing: border-box;
            resize: none;
            z-index: 100;
            min-width: 150px;
            min-height: 50px;
        }
        
        /* Scenes panel styling */
        #scenesPanel {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            min-width: 200px;
            max-width: 300px;
            z-index: 1000;
            transition: all 0.3s ease;
        }
        
        #scenesPanel.collapsed {
            height: 40px;
            overflow: hidden;
        }
        
        #scenesPanel.collapsed #scenesList,
        #scenesPanel.collapsed #scenesControls {
            display: none;
        }
        
        /* Large play/stop button for collapsed panel */
        #scenesPanel.collapsed #largePlayBtn {
            display: inline-block;
        }
        
        #scenesPanel.collapsed #largeStopBtn {
            display: inline-block;
        }
        
        #largePlayBtn, #largeStopBtn {
            margin-left: 10px;
            width: 0;
            height: 0;
            border: none;
            cursor: pointer;
            display: none;
            transition: all 0.2s ease;
            vertical-align: middle;
            padding: 0;
            box-sizing: border-box;
        }
        
        #largePlayBtn {
            border-left: 12px solid #28a745;
            border-top: 8px solid transparent;
            border-bottom: 8px solid transparent;
            margin-right: 5px;
        }
        
        #largeStopBtn {
            width: 16px;
            height: 16px;
            background-color: #dc3545;
            border-radius: 0;
        }
        
        #largePlayBtn:hover {
            border-left-color: #218838;
            transform: scale(1.1);
        }
        
        #largeStopBtn:hover {
            background-color: #c82333;
            transform: scale(1.1);
        }
        
        #scenesHeader {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        #scenesHeader h3 {
            flex: 1;
            margin-right: 10px;
        }
        
        #scenesPlayControls {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 5px;
        }
        
        #scenesPanel h3 {
            margin: 0;
            font-family: 'Inter', sans-serif;
            font-size: 16px;
            color: #333;
        }
        
        #toggleScenesBtn {
            background: none;
            border: none;
            font-size: 12px;
            cursor: pointer;
            padding: 2px 6px;
            border-radius: 3px;
            transition: background-color 0.2s;
        }
        
        #toggleScenesBtn:hover {
            background-color: rgba(0, 0, 0, 0.1);
        }
        
        #scenesList {
            max-height: 200px;
            overflow-y: auto;
            margin-bottom: 10px;
        }
        
        .scene-item {
            display: flex;
            align-items: center;
            padding: 8px;
            margin: 2px 0;
            background-color: #f8f9fa;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .scene-item:hover {
            background-color: #e9ecef;
        }
        
        .scene-item.selected {
            background-color: #007bff;
            color: white;
        }
        
        .scene-name {
            flex: 1;
            font-family: 'Inter', sans-serif;
            font-size: 14px;
            cursor: text;
        }
        
        /* Make emoji icons larger on buttons */
        button {
            padding: 8px 12px; border-radius: 6px; border: 1px solid #ccc;
            background-color: #fff; cursor: pointer; font-size: 16px; font-family: 'Inter', sans-serif;
        }
        
        .scene-name.editing {
            background-color: white;
            border: 1px solid #007bff;
            border-radius: 3px;
            padding: 2px 4px;
            outline: none;
        }
        
        .scene-edit-icon {
            margin-left: 8px;
            cursor: pointer;
            opacity: 0.6;
            transition: opacity 0.2s;
            font-size: 12px;
        }
        
        .scene-edit-icon:hover {
            opacity: 1;
        }
        
        .scene-item:hover .scene-edit-icon {
            opacity: 0.8;
        }
        
        #scenesControls {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }
        
        #scenesControls button {
            flex: 1;
            min-width: 60px;
            font-size: 12px;
            padding: 6px 8px;
        }
    </style>
</head>
<body>
    <!-- Loading indicator shown while fonts load -->
    <div id="loadingIndicator" style="display: none;">Loading Fonts...</div>

    <!-- Main control panel with all tool buttons -->
    <div id="controls">
        <button id="undoBtn" title="Undo last action (Ctrl+Z)">‚Ü∂</button>
        <button id="redoBtn" disabled="" title="Redo last action (Ctrl+Y)">‚Ü∑</button>
        <button id="addBubbleBtn" title="Add a new bubble. Or, double click on canvas to add bubble.">+üí≠</button>
        <button id="addTextBtn" title="Add a text annotation">+‚úèÔ∏è</button>
        <button id="addImageBtn" title="Add an image">+üñºÔ∏è</button>
        <button id="zoomExtentsBtn" title="Zoom to fit all content (Z)">‚§¢ Zoom to Fit</button>
        <button id="forceLayoutBtn" title="Auto-arrange elements">Auto Layout</button>
        <button id="revertLayoutBtn" disabled="" title="Revert to original layout">Revert Layout</button>
        <button id="newBtn" title="Start a new mindmap (will prompt to save if needed)">üÜï New</button>
        <button id="saveBtn" title="Save mindmap (Ctrl+S)">üíæ Save</button>
        <button id="bundleBtn" title="Create self-contained bundle">üì¶ Bundle</button>
        <button id="loadBtn" title="Load mindmap file">üìÇ Load</button>
        <button id="exportGexfBtn" title="Export to GEXF format">üï∏Ô∏è Export GEXF</button>
        <input type="file" id="loadFile" accept=".json">
        <div id="colorPalette"><div class="color-swatch selected" title="#87CEEB" data-color="#87CEEB" style="background-color: rgb(135, 206, 235);"></div><div class="color-swatch" title="#98FB98" data-color="#98FB98" style="background-color: rgb(152, 251, 152);"></div><div class="color-swatch" title="#FFD700" data-color="#FFD700" style="background-color: rgb(255, 215, 0);"></div><div class="color-swatch" title="#FFA07A" data-color="#FFA07A" style="background-color: rgb(255, 160, 122);"></div><div class="color-swatch" title="#DDA0DD" data-color="#DDA0DD" style="background-color: rgb(221, 160, 221);"></div><div class="color-swatch" title="#F08080" data-color="#F08080" style="background-color: rgb(240, 128, 128);"></div><div class="color-swatch" title="Transparent" data-color="transparent" style="background: linear-gradient(45deg, rgb(204, 204, 204) 25%, transparent 25%) 0px 0px / 8px 8px, linear-gradient(-45deg, rgb(204, 204, 204) 25%, transparent 25%) 0px 4px, linear-gradient(45deg, transparent 75%, rgb(204, 204, 204) 75%) 4px -4px, linear-gradient(-45deg, transparent 75%, rgb(204, 204, 204) 75%) -4px 0px;"></div></div>
        <span>Middle-click on bubbles to connect.</span>
    </div>

    <!-- Scenes panel -->
    <div id="scenesPanel">
        <div id="scenesPlayControls">
            <button id="largePlayBtn" title="Play scenes" disabled="" style="display: inline-block;"></button>
            <button id="largeStopBtn" title="Stop scenes" style="display: none;"></button>
        </div>
        <div id="scenesHeader">
            <h3>Scenes</h3>
            <button id="toggleScenesBtn" title="Expand/Collapse scenes panel">‚ñº</button>
        </div>
        <div id="scenesList"></div>
        <div id="scenesControls">
            <button id="addSceneBtn">Add Scene</button>
            <button id="removeSceneBtn" disabled="">Remove Scene</button>
            <button id="playScenesBtn" disabled="">‚ñ∂Ô∏è Play</button>
        </div>
        <div id="countdownTimer" style="display: none; text-align: center; margin-top: 10px; font-family: 'Inter', sans-serif; font-size: 14px; color: #666;">
            <span id="countdownText">Next scene in: <span id="countdownValue">5</span>s</span>
        </div>
    </div>

    <!-- Help button -->
    <button id="helpBtn">?</button>

    <!-- Help modal with instructions -->
    <div id="helpModal">
        <div class="modal-content">
            <h2>Mind Map Help</h2>
            <h4>Mouse Controls</h4>
            <ul>
                <li><b>Connect Bubbles:</b> <b>Middle-click</b> a bubble, drag, and <b>middle-click</b> another bubble.</li>
                <li><b>Pan:</b> <b>Left-click</b> and drag on the empty canvas.</li>
                <li><b>Zoom:</b> Use the mouse scroll wheel.</li>
                <li><b>Move Element:</b> <b>Left-click</b> and drag any element.</li>
                <li><b>Label Connection:</b> Double-left-click on a connection line.</li>
                <li><b>Quick Add Bubble:</b> Double-left-click on the empty canvas to open text input.</li>
                <li><b>Context Menu:</b> <b>Right-click</b> on an element for more options.</li>
            </ul>
            <h4>Keyboard Shortcuts</h4>
            <ul>
                <li><kbd>Ctrl/Cmd</kbd> + <kbd>Z</kbd> - Undo last action.</li>
                <li><kbd>Ctrl/Cmd</kbd> + <kbd>Y</kbd> - Redo last action.</li>
                <li><kbd>B</kbd> - Add a new bubble.</li>
                <li><kbd>A</kbd> - Add a new annotation.</li>
                <li><kbd>I</kbd> - Add a new image.</li>
                <li><kbd>Z</kbd> - Zoom to fit all content.</li>
                <li><kbd>Delete</kbd> / <kbd>Backspace</kbd> - Delete selected element.</li>
                <li><kbd>+</kbd> / <kbd>-</kbd> - Enlarge/shrink selected element.</li>
                <li><kbd>Ctrl/Cmd</kbd> + <kbd>C</kbd> - Copy selected element.</li>
                <li><kbd>Ctrl/Cmd</kbd> + <kbd>V</kbd> - Paste element.</li>
                <li><kbd>Ctrl/Cmd</kbd> + <kbd>S</kbd> - Save mind map to a file.</li>
            </ul>
            <button class="close-modal-btn" style="float: right;">Close</button>
        </div>
    </div>
    
    <!-- Comment modal for viewing/editing bubble comments -->
    <div id="commentModal">
        <div class="modal-content">
            <h2>Comment</h2>
            <p id="commentDisplay"></p>
            <button class="close-modal-btn" style="float: right;">Close</button>
        </div>
    </div>

    <!-- Context menu that appears on right-click -->
    <div id="contextMenu" style="display: none; left: 1889px; top: 355px;" data-world-x="-3.96199890734635" data-world-y="255.08369501454288">
        <button id="addBubbleContextBtn" style="display: none;">Add Bubble</button>
        <button id="addAnnotationContextBtn" style="display: none;">Add Annotation</button>
        <button id="addImageContextBtn" style="display: none;">Add Image</button>
        <hr id="elementSeparator" style="display: none;">
        <button id="growBtn" style="display: block;">Grow</button>
        <button id="shrinkBtn" style="display: block;">Shrink</button>
        <hr id="sizeSeparator" style="display: block;">
        <button id="commentBtn" style="display: block;">Add/Edit Comment</button>
        <button id="viewCommentBtn" style="display: none;">View Comment</button>
        <hr id="linkSeparator" style="display: block;">
        <button id="linkBtn" style="display: block;">Add/Edit Link</button>
        <button id="openLinkBtn" style="display: none;">Open Link</button>
        <hr id="deleteSeparator" style="display: block;">
        <button id="deleteBtn" style="display: block;">Delete</button>
    </div>

    <!-- Scene name overlay for playback -->
    <div id="sceneNameOverlay" style="display: none; position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background-color: rgba(0, 0, 0, 0.8); color: white; padding: 15px 30px; border-radius: 10px; font-family: 'Inter', sans-serif; font-size: 24px; font-weight: bold; z-index: 2000; box-shadow: 0 4px 12px rgba(0,0,0,0.3);">
        <span id="currentSceneName"></span>
    </div>

    <!-- Main canvas where the mindmap is drawn -->
    <canvas id="canvas" tabindex="0" width="2270" height="1314" class=""></canvas>
    
    <!-- Hidden text input for creating new bubbles -->
    <textarea id="textInput" style="display: none; left: 1103.26px; top: 269.794px;"></textarea>

    <script>
        // --- Embedded Mindmap Data ---
        const embeddedDataEncoded = 'ewogICJlbGVtZW50cyI6IFsKICAgIHsKICAgICAgInR5cGUiOiAiYnViYmxlIiwKICAgICAgImlkIjogMTc2NTI5NDU3NjUxNywKICAgICAgIngiOiAtODcuNTA0NDU5MzM3MTM3NzcsCiAgICAgICJ5IjogMTAxLjM0NTE2OTA3NjkxMTIyLAogICAgICAidGV4dCI6ICJTQVMgVGVjaCBQbGF0Zm9ybSIsCiAgICAgICJyYWRpdXNYIjogOTYuMjE1OTM0NzUzNDE3OTcsCiAgICAgICJyYWRpdXNZIjogMjguNzk5OTk5OTk5OTk5OTk3LAogICAgICAiY29sb3IiOiAiIzg3Q0VFQiIsCiAgICAgICJmb250U2l6ZSI6IDE2LAogICAgICAiY29tbWVudCI6ICJUaGlzIGlzIGEgaGlkZGVuIG5vdGUuIFJpZ2h0LWNsaWNrIHRvIHZpZXcgb3IgZWRpdC4iCiAgICB9LAogICAgewogICAgICAidHlwZSI6ICJidWJibGUiLAogICAgICAiaWQiOiAxNzY1Mjk0NTk0MDM0LjM3OTQsCiAgICAgICJ4IjogLTYwLjcxNTg5NTQ1NTU2NjQ4LAogICAgICAieSI6IC05LjM5MjA1MjI3MjIxNjc3LAogICAgICAidGV4dCI6ICJGcmFjdGFsIiwKICAgICAgInJhZGl1c1giOiA1MS41Njc5NzAyNzU4Nzg5MDYsCiAgICAgICJyYWRpdXNZIjogMjguNzk5OTk5OTk5OTk5OTk3LAogICAgICAiZm9udFNpemUiOiAxNiwKICAgICAgImNvbG9yIjogIiM4N0NFRUIiLAogICAgICAiZm9udCI6ICJQb3BwaW5zLCBzYW5zLXNlcmlmIgogICAgfSwKICAgIHsKICAgICAgInR5cGUiOiAiYnViYmxlIiwKICAgICAgImlkIjogMTc2NTI5NDYwMjA5Ny40NzMsCiAgICAgICJ4IjogMTAzLjUsCiAgICAgICJ5IjogMTcxLjUsCiAgICAgICJ0ZXh0IjogIlwiVGhlIE9ic3RhY2xlXG5pcyB0aGUgV2F5XCIiLAogICAgICAicmFkaXVzWCI6IDc4Ljg1NTk0OTQwMTg1NTQ3LAogICAgICAicmFkaXVzWSI6IDM4LjQsCiAgICAgICJmb250U2l6ZSI6IDE2LAogICAgICAiY29sb3IiOiAiIzg3Q0VFQiIsCiAgICAgICJmb250IjogIlBvcHBpbnMsIHNhbnMtc2VyaWYiCiAgICB9LAogICAgewogICAgICAidHlwZSI6ICJidWJibGUiLAogICAgICAiaWQiOiAxNzY1Mjk0NjI5NzU5Ljg1MDYsCiAgICAgICJ4IjogMTIzLjIyMTg0NjY4MjU5MzkzLAogICAgICAieSI6IDM3NS4xNjYzODQyNDQ1NzUxNywKICAgICAgInRleHQiOiAiTGltaXRlZCBiYW5kd2lkdGgtLT5cbiBydW4gd2lyZWdhcHBlZCIsCiAgICAgICJyYWRpdXNYIjogMTExLjQ4NzkyMjY2ODQ1NzAzLAogICAgICAicmFkaXVzWSI6IDM4LjQsCiAgICAgICJmb250U2l6ZSI6IDE2LAogICAgICAiY29sb3IiOiAiIzg3Q0VFQiIsCiAgICAgICJmb250IjogIlBvcHBpbnMsIHNhbnMtc2VyaWYiCiAgICB9LAogICAgewogICAgICAidHlwZSI6ICJidWJibGUiLAogICAgICAiaWQiOiAxNzY1Mjk0NjQ0ODQ4Ljc5NzksCiAgICAgICJ4IjogMzEyLjI4MzcxMTk5NDQ4MjcsCiAgICAgICJ5IjogMjY2LjkwNjQxODQ5MDEwODMsCiAgICAgICJ0ZXh0IjogImxpbWl0ZWQgcG93ZXItLT5cbnJ1biBkaXN0cmlidXRlZCIsCiAgICAgICJyYWRpdXNYIjogOTEuNzE5OTQwMTg1NTQ2ODgsCiAgICAgICJyYWRpdXNZIjogMzguNCwKICAgICAgImZvbnRTaXplIjogMTYsCiAgICAgICJjb2xvciI6ICIjODdDRUVCIiwKICAgICAgImZvbnQiOiAiUG9wcGlucywgc2Fucy1zZXJpZiIKICAgIH0sCiAgICB7CiAgICAgICJ0eXBlIjogImJ1YmJsZSIsCiAgICAgICJpZCI6IDE3NjUyOTQ2NzMwNjAuMjI4OCwKICAgICAgIngiOiAzNjMuNjQxODAwNDIxNzMxMjYsCiAgICAgICJ5IjogMTQ1LjczODQ2MDU0NzQ1MDUsCiAgICAgICJ0ZXh0IjogImxpbWl0ZWQgdGltZS0tPlxucnVuIHNpbXBsZSIsCiAgICAgICJyYWRpdXNYIjogODQuNzY3OTQ0MzM1OTM3NSwKICAgICAgInJhZGl1c1kiOiAzOC40LAogICAgICAiZm9udFNpemUiOiAxNiwKICAgICAgImNvbG9yIjogIiM4N0NFRUIiLAogICAgICAiZm9udCI6ICJQb3BwaW5zLCBzYW5zLXNlcmlmIgogICAgfSwKICAgIHsKICAgICAgInR5cGUiOiAiYnViYmxlIiwKICAgICAgImlkIjogMTc2NTI5NDgwOTI5Ni4xMTE2LAogICAgICAieCI6IDE1Ny41LAogICAgICAieSI6IDU2LjUsCiAgICAgICJ0ZXh0IjogIk11c3Qgd29yayB3L1xucGVvcGxlLXRlY2ggb25seSIsCiAgICAgICJyYWRpdXNYIjogOTIuOTI3OTQwMzY4NjUyMzQsCiAgICAgICJyYWRpdXNZIjogMzguNCwKICAgICAgImZvbnRTaXplIjogMTYsCiAgICAgICJjb2xvciI6ICIjODdDRUVCIiwKICAgICAgImZvbnQiOiAiUG9wcGlucywgc2Fucy1zZXJpZiIsCiAgICAgICJjb21tZW50IjogIlRoaXMgZW5hYmxlcyB0aGUgc3ByaW5nIHByb3RvdHlwZSIKICAgIH0sCiAgICB7CiAgICAgICJ0eXBlIjogImJ1YmJsZSIsCiAgICAgICJpZCI6IDE3NjUyOTQ5MDkzMjAuMjE1MywKICAgICAgIngiOiAtMjgyLjk0NjU5ODU5Mjg4NTMsCiAgICAgICJ5IjogMjIuNTA4Mjc5MTUzMTIzMjk0LAogICAgICAidGV4dCI6ICJBcyBhIHBlcnNvbiBpc1xudG8gdGhlIGdyb3VwLFxuc28gdGhlIGdyb3VwIGlzXG50byBsYXJnZXIgZ3JvdXBzIiwKICAgICAgInJhZGl1c1giOiA4OC4yMzE5MjU5NjQzNTU0NywKICAgICAgInJhZGl1c1kiOiA1Ny41OTk5OTk5OTk5OTk5OTQsCiAgICAgICJmb250U2l6ZSI6IDE2LAogICAgICAiY29sb3IiOiAiIzg3Q0VFQiIsCiAgICAgICJmb250IjogIlBvcHBpbnMsIHNhbnMtc2VyaWYiCiAgICB9LAogICAgewogICAgICAidHlwZSI6ICJidWJibGUiLAogICAgICAiaWQiOiAxNzY1Mjk0OTg4NzE0Ljg4NiwKICAgICAgIngiOiAtOTYuNjU2MjUyNTI4NjE4OTgsCiAgICAgICJ5IjogMzAyLjk5NDgwNjcyMjc1MzksCiAgICAgICJ0ZXh0IjogIlNvdmVyZWlnbiBBSSIsCiAgICAgICJyYWRpdXNYIjogNzMuMTk5OTU4ODAxMjY5NTMsCiAgICAgICJyYWRpdXNZIjogMjguNzk5OTk5OTk5OTk5OTk3LAogICAgICAiZm9udFNpemUiOiAxNiwKICAgICAgImNvbG9yIjogIiM4N0NFRUIiLAogICAgICAiZm9udCI6ICJQb3BwaW5zLCBzYW5zLXNlcmlmIgogICAgfSwKICAgIHsKICAgICAgInR5cGUiOiAiYnViYmxlIiwKICAgICAgImlkIjogMTc2NTQ5NjQzNjM0MC44OTI4LAogICAgICAieCI6IC0xMTAuNjg4MjM2MzQ2ODE1OTcsCiAgICAgICJ5IjogNDM2LjU0NzQ4NjYzODI5NzcsCiAgICAgICJ0ZXh0IjogInRoZSBkb2NzIHN0YXlcbmF0IHRoZSBzb3VyY2UiLAogICAgICAicmFkaXVzWCI6IDc3LjgyMzk0NDA5MTc5Njg4LAogICAgICAicmFkaXVzWSI6IDM4LjQsCiAgICAgICJmb250U2l6ZSI6IDE2LAogICAgICAiY29sb3IiOiAiIzg3Q0VFQiIsCiAgICAgICJmb250IjogIlBvcHBpbnMsIHNhbnMtc2VyaWYiCiAgICB9LAogICAgewogICAgICAidHlwZSI6ICJidWJibGUiLAogICAgICAiaWQiOiAxNzY1NDk2NDY3NDE4LjkxMzgsCiAgICAgICJ4IjogLTE4OS45NzY4OTIxNjYzODQyMywKICAgICAgInkiOiA1NjguNTY0NDk5NjY3MDcxMiwKICAgICAgInRleHQiOiAibG9jYWwgYXBwIG9uXG5sYXB0b3AgY291bGRcbmNvbnRyb2wgYWNjZXNzIiwKICAgICAgInJhZGl1c1giOiA4Mi42NDc5MzM5NTk5NjA5NCwKICAgICAgInJhZGl1c1kiOiA0OCwKICAgICAgImZvbnRTaXplIjogMTYsCiAgICAgICJjb2xvciI6ICIjODdDRUVCIiwKICAgICAgImZvbnQiOiAiUG9wcGlucywgc2Fucy1zZXJpZiIKICAgIH0sCiAgICB7CiAgICAgICJ0eXBlIjogImJ1YmJsZSIsCiAgICAgICJpZCI6IDE3NjU0OTY0ODk0MzguOTU2MywKICAgICAgIngiOiAxMTQuMTkwMzc1NTI5OTgwNTEsCiAgICAgICJ5IjogNTU5LjI3NTEwODExNDgzOTYsCiAgICAgICJ0ZXh0IjogIlNpbmdsZSBBMTAwIG1hY2hpbmVcbig4MEdCIFZSQU0pIH4kMjBLIiwKICAgICAgInJhZGl1c1giOiAxMDYuMDYzOTI2Njk2Nzc3MzQsCiAgICAgICJyYWRpdXNZIjogMzguNCwKICAgICAgImZvbnRTaXplIjogMTYsCiAgICAgICJjb2xvciI6ICIjODdDRUVCIiwKICAgICAgImZvbnQiOiAiUG9wcGlucywgc2Fucy1zZXJpZiIKICAgIH0sCiAgICB7CiAgICAgICJ0eXBlIjogImJ1YmJsZSIsCiAgICAgICJpZCI6IDE3NjU0OTY2MjYyNDAuMTA5NCwKICAgICAgIngiOiAtMzUzLjc0MTE5NTgxMjIwOTQ3LAogICAgICAieSI6IDI1Ny4wOTk3MTM0NDA1MDc0NiwKICAgICAgInRleHQiOiAiaG93IGRvIHlvdVxucmVwcmVzZW50IHBlb3BsZVxuaW4geW91ciBncm91cD9cbm9yLCBncm91cHNcbmluIHlvdXIgZ3JvdXA/IiwKICAgICAgInJhZGl1c1giOiA5Mi40MjM5NDI1NjU5MTc5NywKICAgICAgInJhZGl1c1kiOiA2Ny4yLAogICAgICAiZm9udFNpemUiOiAxNiwKICAgICAgImNvbG9yIjogIiM4N0NFRUIiLAogICAgICAiZm9udCI6ICJQb3BwaW5zLCBzYW5zLXNlcmlmIgogICAgfSwKICAgIHsKICAgICAgInR5cGUiOiAiYnViYmxlIiwKICAgICAgImlkIjogMTc2NTQ5NjY4Mjk1Mi44NjIsCiAgICAgICJ4IjogMjY4LjIwMDQ4ODU5Nzg3OTAzLAogICAgICAieSI6IC0xMzcuMDMxODg4ODM1NTc3NSwKICAgICAgInRleHQiOiAiZXZlcnkgc3R1ZGVudFxud3JpdGVzIGEgcGVyc29uYWxcbnByb2ZpbGUgZG9jIChvciBkb2NzKSIsCiAgICAgICJyYWRpdXNYIjogMTA1Ljc1OTkwMjk1NDEwMTU2LAogICAgICAicmFkaXVzWSI6IDQ4LAogICAgICAiZm9udFNpemUiOiAxNiwKICAgICAgImNvbG9yIjogIiM4N0NFRUIiLAogICAgICAiZm9udCI6ICJQb3BwaW5zLCBzYW5zLXNlcmlmIgogICAgfSwKICAgIHsKICAgICAgInR5cGUiOiAiYnViYmxlIiwKICAgICAgImlkIjogMTc2NTQ5NjcwOTI3OC4yNDE1LAogICAgICAieCI6IDguMDQ1NjM5OTAxODc5NzEsCiAgICAgICJ5IjogLTIzMC44MTA5NTE2MzE4MzY0NSwKICAgICAgInRleHQiOiAicmVhZCBhIGZld1xub3RoZXIgcGVvcGxlJ3NcbnByb2ZpbGUgZG9jcyIsCiAgICAgICJyYWRpdXNYIjogODAuNTAzOTQ0Mzk2OTcyNjYsCiAgICAgICJyYWRpdXNZIjogNDgsCiAgICAgICJmb250U2l6ZSI6IDE2LAogICAgICAiY29sb3IiOiAiIzg3Q0VFQiIsCiAgICAgICJmb250IjogIlBvcHBpbnMsIHNhbnMtc2VyaWYiCiAgICB9LAogICAgewogICAgICAidHlwZSI6ICJidWJibGUiLAogICAgICAiaWQiOiAxNzY1NDk2NzYwNjA4Ljc1OTUsCiAgICAgICJ4IjogLTM1Mi43MzEwNTE2Nzk4NTI5NSwKICAgICAgInkiOiAtMjUwLjc0Mzc2NjY3MTEyMTAyLAogICAgICAidGV4dCI6ICJtZWV0IHNvbWVvbmVcbnJhbmRvbS4gc3VtbWFyaXplL3NoYXJlXG4gYSBmZXcgZm9sa3MgeW91IGtub3cuIiwKICAgICAgInJhZGl1c1giOiAxMzEuMjg3OTEwNDYxNDI1NzgsCiAgICAgICJyYWRpdXNZIjogNDgsCiAgICAgICJmb250U2l6ZSI6IDE2LAogICAgICAiY29sb3IiOiAiIzg3Q0VFQiIsCiAgICAgICJmb250IjogIlBvcHBpbnMsIHNhbnMtc2VyaWYiLAogICAgICAiY29tbWVudCI6ICJDcmVhdGUgZHlhZHMuIENhbiBiZSBsZWFkZXIgZGlyZWN0ZWQgb3IgcmFuZG9tIGJ1dCBzaG91bGQgYmUgd2VsbC1taXhlZCBpbiB0aGUgcm9vbS4iCiAgICB9LAogICAgewogICAgICAidHlwZSI6ICJidWJibGUiLAogICAgICAiaWQiOiAxNzY1NDk2ODE3NzAyLjM4OSwKICAgICAgIngiOiAtNjMxLjQ2NjY5NTU5NzMwODMsCiAgICAgICJ5IjogLTEyNC43ODQ4Njk1MDUyMTI5NywKICAgICAgInRleHQiOiAibWFrZSBpbnRyb3MgaWYgeW91XG5maW5kIGEgcG9zc2libGUgbWF0Y2giLAogICAgICAicmFkaXVzWCI6IDExMC42NjM5MDk5MTIxMDkzOCwKICAgICAgInJhZGl1c1kiOiAzOC40LAogICAgICAiZm9udFNpemUiOiAxNiwKICAgICAgImNvbG9yIjogIiM4N0NFRUIiLAogICAgICAiZm9udCI6ICJQb3BwaW5zLCBzYW5zLXNlcmlmIgogICAgfSwKICAgIHsKICAgICAgInR5cGUiOiAiYnViYmxlIiwKICAgICAgImlkIjogMTc2NTQ5NjgzMjQyMy44MTMsCiAgICAgICJ4IjogLTc4MC4yNjM3MjA1Mzg3ODIyLAogICAgICAieSI6IC0yNS45MjE0OTQwNzAxNjYzOTMsCiAgICAgICJ0ZXh0IjogInBlb3BsZSBjYW4gXG5mb3JtIGFcbnByb3RvLXRlYW0gaWZcbnRoZXkgd2FudCIsCiAgICAgICJyYWRpdXNYIjogNzguMjA3OTQ2Nzc3MzQzNzUsCiAgICAgICJyYWRpdXNZIjogNTcuNTk5OTk5OTk5OTk5OTk0LAogICAgICAiZm9udFNpemUiOiAxNiwKICAgICAgImNvbG9yIjogIiM4N0NFRUIiLAogICAgICAiZm9udCI6ICJQb3BwaW5zLCBzYW5zLXNlcmlmIgogICAgfSwKICAgIHsKICAgICAgInR5cGUiOiAiYnViYmxlIiwKICAgICAgImlkIjogMTc2NTQ5NzE1MDE1Mi4xNDU4LAogICAgICAieCI6IC0zOTAuOTg1MDk4ODQ4MzIyMSwKICAgICAgInkiOiA1MTcuMDczNDcxNjA3MDE0NywKICAgICAgInRleHQiOiAiZW5hYmxlcyBSQUdcbnZpYSBsb2NhbCBmaWxlc2VydmVyIiwKICAgICAgInJhZGl1c1giOiA5NS41MzU5MTkxODk0NTMxMiwKICAgICAgInJhZGl1c1kiOiAzOC40LAogICAgICAiZm9udFNpemUiOiAxNiwKICAgICAgImNvbG9yIjogIiM4N0NFRUIiLAogICAgICAiZm9udCI6ICJQb3BwaW5zLCBzYW5zLXNlcmlmIgogICAgfSwKICAgIHsKICAgICAgInR5cGUiOiAiYnViYmxlIiwKICAgICAgImlkIjogMTc2NTQ5NzIyMDA4OC40MTY3LAogICAgICAieCI6IC02NjkuNjQ2Mjk0NDM2OTg2NSwKICAgICAgInkiOiAxMjAuNzEwNjE1Nzg3NzU4NjgsCiAgICAgICJ0ZXh0IjogInBlb3BsZSBrZWVwXG50aGVpciBvd25cbmNvbm5lY3Rpb24gbGlzdCIsCiAgICAgICJyYWRpdXNYIjogODIuMzExOTI3Nzk1NDEwMTYsCiAgICAgICJyYWRpdXNZIjogNDgsCiAgICAgICJmb250U2l6ZSI6IDE2LAogICAgICAiY29sb3IiOiAiIzg3Q0VFQiIsCiAgICAgICJmb250IjogIlBvcHBpbnMsIHNhbnMtc2VyaWYiCiAgICB9LAogICAgewogICAgICAidHlwZSI6ICJidWJibGUiLAogICAgICAiaWQiOiAxNzY1NDk3NDQ5ODk0Ljg1MjgsCiAgICAgICJ4IjogLTcxMi45MDQxNjk1NjQ0Njg3LAogICAgICAieSI6IC0zMTcuOTA0MTE4MDYyOTkxNCwKICAgICAgInRleHQiOiAicHJhY3RpY2U6IHRlbGwgc29tZW9uZVxuZmF2b3JpdGUgaWRlYSwgYW5kXG5hdHRyaWJ1dGUgaXQgKGdpdmUgY3JlZGl0KSIsCiAgICAgICJyYWRpdXNYIjogMTE3LjA0Nzg4OTcwOTQ3MjY2LAogICAgICAicmFkaXVzWSI6IDQ4LAogICAgICAiZm9udFNpemUiOiAxNiwKICAgICAgImNvbG9yIjogIiM4N0NFRUIiLAogICAgICAiZm9udCI6ICJQb3BwaW5zLCBzYW5zLXNlcmlmIgogICAgfSwKICAgIHsKICAgICAgInR5cGUiOiAiYnViYmxlIiwKICAgICAgImlkIjogMTc2NTQ5Nzk5MjMwNC4xMjE4LAogICAgICAieCI6IDUyMi40NjAyNjQzMDg3NDQ2LAogICAgICAieSI6IDMzNS45OTM5OTQzMjkxODIsCiAgICAgICJ0ZXh0IjogInNpbmdsZSBsYXB0b3BzXG5jYW4gcHJlLXByb2Nlc3NcbnRoZWlyIHdvcmQgZW1iZWRkaW5ncyIsCiAgICAgICJyYWRpdXNYIjogMTE3LjM0MzkxNzg0NjY3OTY5LAogICAgICAicmFkaXVzWSI6IDQ4LAogICAgICAiZm9udFNpemUiOiAxNiwKICAgICAgImNvbG9yIjogIiM4N0NFRUIiLAogICAgICAiZm9udCI6ICJQb3BwaW5zLCBzYW5zLXNlcmlmIgogICAgfQogIF0sCiAgImNvbm5lY3Rpb25zIjogWwogICAgewogICAgICAiaWQiOiAxNzY1NDk0NDM0MDc4LjQ4MzIsCiAgICAgICJmcm9tIjogMTc2NTI5NDkwOTMyMC4yMTUzLAogICAgICAidG8iOiAxNzY1Mjk0NTk0MDM0LjM3OTQsCiAgICAgICJ3ZWlnaHQiOiAxCiAgICB9LAogICAgewogICAgICAiaWQiOiAxNzY1NDk0NDQxMzQ4LjY0OTcsCiAgICAgICJmcm9tIjogMTc2NTI5NDU3NjUxNywKICAgICAgInRvIjogMTc2NTI5NDU5NDAzNC4zNzk0LAogICAgICAid2VpZ2h0IjogMQogICAgfSwKICAgIHsKICAgICAgImlkIjogMTc2NTQ5NDQ0NjY3My44NjA2LAogICAgICAiZnJvbSI6IDE3NjUyOTQ2MDIwOTcuNDczLAogICAgICAidG8iOiAxNzY1Mjk0ODA5Mjk2LjExMTYsCiAgICAgICJ3ZWlnaHQiOiAxCiAgICB9LAogICAgewogICAgICAiaWQiOiAxNzY1NDk0NDQ4NTAyLjk3NywKICAgICAgImZyb20iOiAxNzY1Mjk0NjAyMDk3LjQ3MywKICAgICAgInRvIjogMTc2NTI5NDY3MzA2MC4yMjg4LAogICAgICAid2VpZ2h0IjogMQogICAgfSwKICAgIHsKICAgICAgImlkIjogMTc2NTQ5NDQ1MDMyMy4yNjYsCiAgICAgICJmcm9tIjogMTc2NTI5NDYwMjA5Ny40NzMsCiAgICAgICJ0byI6IDE3NjUyOTQ2NDQ4NDguNzk3OSwKICAgICAgIndlaWdodCI6IDEKICAgIH0sCiAgICB7CiAgICAgICJpZCI6IDE3NjU0OTQ0NTIyODguODI2MiwKICAgICAgImZyb20iOiAxNzY1Mjk0NjAyMDk3LjQ3MywKICAgICAgInRvIjogMTc2NTI5NDYyOTc1OS44NTA2LAogICAgICAid2VpZ2h0IjogMQogICAgfSwKICAgIHsKICAgICAgImlkIjogMTc2NTQ5NDQ2ODYyNS4zODQ4LAogICAgICAiZnJvbSI6IDE3NjUyOTQ2Mjk3NTkuODUwNiwKICAgICAgInRvIjogMTc2NTI5NDk4ODcxNC44ODYsCiAgICAgICJ3ZWlnaHQiOiAxCiAgICB9LAogICAgewogICAgICAiaWQiOiAxNzY1NDk0NDc1MTAyLjk2NjYsCiAgICAgICJmcm9tIjogMTc2NTI5NDk4ODcxNC44ODYsCiAgICAgICJ0byI6IDE3NjUyOTQ5MDkzMjAuMjE1MywKICAgICAgIndlaWdodCI6IDEKICAgIH0sCiAgICB7CiAgICAgICJpZCI6IDE3NjU0OTY0NzA5NTMuNTg0MiwKICAgICAgImZyb20iOiAxNzY1NDk2NDM2MzQwLjg5MjgsCiAgICAgICJ0byI6IDE3NjU0OTY0Njc0MTguOTEzOCwKICAgICAgIndlaWdodCI6IDEKICAgIH0sCiAgICB7CiAgICAgICJpZCI6IDE3NjU0OTY0NzI5MzEuOTYyNiwKICAgICAgImZyb20iOiAxNzY1Mjk0OTg4NzE0Ljg4NiwKICAgICAgInRvIjogMTc2NTQ5NjQzNjM0MC44OTI4LAogICAgICAid2VpZ2h0IjogMQogICAgfSwKICAgIHsKICAgICAgImlkIjogMTc2NTQ5NjQ5ODU0OC44MzUyLAogICAgICAiZnJvbSI6IDE3NjUyOTQ2Mjk3NTkuODUwNiwKICAgICAgInRvIjogMTc2NTQ5NjQ4OTQzOC45NTYzLAogICAgICAid2VpZ2h0IjogMQogICAgfSwKICAgIHsKICAgICAgImlkIjogMTc2NTQ5NjYyOTIxNi4wMDA1LAogICAgICAiZnJvbSI6IDE3NjU0OTY2MjYyNDAuMTA5NCwKICAgICAgInRvIjogMTc2NTI5NDkwOTMyMC4yMTUzLAogICAgICAid2VpZ2h0IjogMQogICAgfSwKICAgIHsKICAgICAgImlkIjogMTc2NTQ5NjY4NzY5OC4zMDk2LAogICAgICAiZnJvbSI6IDE3NjUyOTQ4MDkyOTYuMTExNiwKICAgICAgInRvIjogMTc2NTQ5NjY4Mjk1Mi44NjIsCiAgICAgICJ3ZWlnaHQiOiAxCiAgICB9LAogICAgewogICAgICAiaWQiOiAxNzY1NDk2NzI1MTgyLjEzNDUsCiAgICAgICJmcm9tIjogMTc2NTQ5NjY4Mjk1Mi44NjIsCiAgICAgICJ0byI6IDE3NjU0OTY3MDkyNzguMjQxNSwKICAgICAgIndlaWdodCI6IDEKICAgIH0sCiAgICB7CiAgICAgICJpZCI6IDE3NjU0OTY4MTA0MTYuNTYzNSwKICAgICAgImZyb20iOiAxNzY1NDk2NzA5Mjc4LjI0MTUsCiAgICAgICJ0byI6IDE3NjU0OTY3NjA2MDguNzU5NSwKICAgICAgIndlaWdodCI6IDEKICAgIH0sCiAgICB7CiAgICAgICJpZCI6IDE3NjU0OTY4MTg5NzMuOTk4MywKICAgICAgImZyb20iOiAxNzY1NDk2NzYwNjA4Ljc1OTUsCiAgICAgICJ0byI6IDE3NjU0OTY4MTc3MDIuMzg5LAogICAgICAid2VpZ2h0IjogMQogICAgfSwKICAgIHsKICAgICAgImlkIjogMTc2NTQ5Njg2NzQ4OC4yNjA1LAogICAgICAiZnJvbSI6IDE3NjU0OTY4MTc3MDIuMzg5LAogICAgICAidG8iOiAxNzY1NDk2ODMyNDIzLjgxMywKICAgICAgIndlaWdodCI6IDEKICAgIH0sCiAgICB7CiAgICAgICJpZCI6IDE3NjU0OTcxNjcxNzguMDgzNSwKICAgICAgImZyb20iOiAxNzY1NDk3MTUwMTUyLjE0NTgsCiAgICAgICJ0byI6IDE3NjU0OTY0Njc0MTguOTEzOCwKICAgICAgIndlaWdodCI6IDEKICAgIH0sCiAgICB7CiAgICAgICJpZCI6IDE3NjU0OTcyNDI1NDEuMjI4LAogICAgICAiZnJvbSI6IDE3NjU0OTY4MTc3MDIuMzg5LAogICAgICAidG8iOiAxNzY1NDk3MjIwMDg4LjQxNjcsCiAgICAgICJ3ZWlnaHQiOiAxCiAgICB9LAogICAgewogICAgICAiaWQiOiAxNzY1NDk3NDUzMDIyLjQwNjcsCiAgICAgICJmcm9tIjogMTc2NTQ5Njc2MDYwOC43NTk1LAogICAgICAidG8iOiAxNzY1NDk3NDQ5ODk0Ljg1MjgsCiAgICAgICJ3ZWlnaHQiOiAxCiAgICB9LAogICAgewogICAgICAiaWQiOiAxNzY1NDk4MDEyMjc2Ljg2MzMsCiAgICAgICJmcm9tIjogMTc2NTI5NDY0NDg0OC43OTc5LAogICAgICAidG8iOiAxNzY1NDk3OTkyMzA0LjEyMTgsCiAgICAgICJ3ZWlnaHQiOiAxCiAgICB9CiAgXSwKICAic2NlbmVzIjogW10sCiAgInRpbWVzdGFtcCI6ICIyMDI1LTEyLTEyVDAwOjA4OjExLjUwMFoiLAogICJ2ZXJzaW9uIjogIjEuMCIKfQ==';
        
        // Load embedded data on startup
        function loadEmbeddedData() {
            try {
                const decodedData = decodeURIComponent(escape(atob(embeddedDataEncoded)));
                const data = JSON.parse(decodedData);
                if (data && data.elements && data.connections) {
                    console.log('Loading embedded mindmap data...');
                    elements = data.elements;
                    connections = data.connections;
                    if (data.scenes) {
                        scenes = data.scenes;
                        updateScenesList();
                        updateScenesButtons();
                    }
                    
                    // Ensure all connections have IDs
                    connections.forEach(c => { if (!c.id) c.id = Date.now() + Math.random(); });
                    selectedElement = null;
                    
                    // Load any images in the mindmap
                    const imagePromises = elements.filter(el => el.type === 'image').map(el => {
                        return loadImage(el.url).then(img => {
                            // Update natural dimensions if not already set
                            if (!el.naturalWidth || !el.naturalHeight) {
                                el.naturalWidth = img.naturalWidth;
                                el.naturalHeight = img.naturalHeight;
                            }
                        }).catch(error => {
                            console.warn('Failed to load image during bundle load:', el.url, error);
                        });
                    });
                    
                    // Update the title to indicate it's a bundled file
                    document.title = 'Mind Mapper - ' + (data.timestamp ? new Date(data.timestamp).toLocaleDateString() : 'Bundled');
                    
                    console.log('Embedded mindmap loaded successfully');
                    
                    // Draw after images are loaded
                    Promise.all(imagePromises).finally(() => {
                        draw();
                    });
                }
            } catch (error) {
                console.error('Error loading embedded data:', error);
            }
        }
        
        // Call load function after DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', loadEmbeddedData);
        } else {
            loadEmbeddedData();
        }
        
        // --- Original Mindmap Code ---

        // --- Embedded Mindmap Data ---
        const embeddedDataEncoded = 'ewogICJlbGVtZW50cyI6IFsKICAgIHsKICAgICAgInR5cGUiOiAiYnViYmxlIiwKICAgICAgImlkIjogMTc2NTI5NDU3NjUxNywKICAgICAgIngiOiAtMzM3Ljk5NzczNjIzODEzOTUsCiAgICAgICJ5IjogLTEwNC44ODQyMzU2MDA2MjAzOSwKICAgICAgInRleHQiOiAiU0FTIFRlY2ggUGxhdGZvcm0iLAogICAgICAicmFkaXVzWCI6IDk2LjIxNTkzNDc1MzQxNzk3LAogICAgICAicmFkaXVzWSI6IDI4Ljc5OTk5OTk5OTk5OTk5NywKICAgICAgImNvbG9yIjogIiM4N0NFRUIiLAogICAgICAiZm9udFNpemUiOiAxNiwKICAgICAgImNvbW1lbnQiOiAiVGhpcyBpcyBhIGhpZGRlbiBub3RlLiBSaWdodC1jbGljayB0byB2aWV3IG9yIGVkaXQuIgogICAgfSwKICAgIHsKICAgICAgInR5cGUiOiAiYnViYmxlIiwKICAgICAgImlkIjogMTc2NTI5NDU5NDAzNC4zNzk0LAogICAgICAieCI6IC0yNC41LAogICAgICAieSI6IC0yNy41LAogICAgICAidGV4dCI6ICJGcmFjdGFsIiwKICAgICAgInJhZGl1c1giOiA1MS41Njc5NzAyNzU4Nzg5MDYsCiAgICAgICJyYWRpdXNZIjogMjguNzk5OTk5OTk5OTk5OTk3LAogICAgICAiZm9udFNpemUiOiAxNiwKICAgICAgImNvbG9yIjogIiM4N0NFRUIiLAogICAgICAiZm9udCI6ICJQb3BwaW5zLCBzYW5zLXNlcmlmIgogICAgfSwKICAgIHsKICAgICAgInR5cGUiOiAiYnViYmxlIiwKICAgICAgImlkIjogMTc2NTI5NDYwMjA5Ny40NzMsCiAgICAgICJ4IjogMTAzLjUsCiAgICAgICJ5IjogMTcxLjUsCiAgICAgICJ0ZXh0IjogIlRoZSBPYnN0YWNsZSBpcyB0aGUgV2F5IiwKICAgICAgInJhZGl1c1giOiAxMTkuNzgzOTA1MDI5Mjk2ODgsCiAgICAgICJyYWRpdXNZIjogMjguNzk5OTk5OTk5OTk5OTk3LAogICAgICAiZm9udFNpemUiOiAxNiwKICAgICAgImNvbG9yIjogIiM4N0NFRUIiLAogICAgICAiZm9udCI6ICJQb3BwaW5zLCBzYW5zLXNlcmlmIgogICAgfSwKICAgIHsKICAgICAgInR5cGUiOiAiYnViYmxlIiwKICAgICAgImlkIjogMTc2NTI5NDYyOTc1OS44NTA2LAogICAgICAieCI6IDE2Mi41LAogICAgICAieSI6IDI4MS41LAogICAgICAidGV4dCI6ICJMaW1pdGVkIGJhbmR3aWR0aC0tPlxuIHJ1biB3aXJlZ2FwcGVkIiwKICAgICAgInJhZGl1c1giOiAxMTEuNDg3OTIyNjY4NDU3MDMsCiAgICAgICJyYWRpdXNZIjogMzguNCwKICAgICAgImZvbnRTaXplIjogMTYsCiAgICAgICJjb2xvciI6ICIjODdDRUVCIiwKICAgICAgImZvbnQiOiAiUG9wcGlucywgc2Fucy1zZXJpZiIKICAgIH0sCiAgICB7CiAgICAgICJ0eXBlIjogImJ1YmJsZSIsCiAgICAgICJpZCI6IDE3NjUyOTQ2NDQ4NDguNzk3OSwKICAgICAgIngiOiAzMzguNSwKICAgICAgInkiOiAyMTQuNSwKICAgICAgInRleHQiOiAibGltaXRlZCBwb3dlci0tPlxucnVuIGRpc3RyaWJ1dGVkIiwKICAgICAgInJhZGl1c1giOiA5MS43MTk5NDAxODU1NDY4OCwKICAgICAgInJhZGl1c1kiOiAzOC40LAogICAgICAiZm9udFNpemUiOiAxNiwKICAgICAgImNvbG9yIjogIiM4N0NFRUIiLAogICAgICAiZm9udCI6ICJQb3BwaW5zLCBzYW5zLXNlcmlmIgogICAgfSwKICAgIHsKICAgICAgInR5cGUiOiAiYnViYmxlIiwKICAgICAgImlkIjogMTc2NTI5NDY3MzA2MC4yMjg4LAogICAgICAieCI6IDMzNi41LAogICAgICAieSI6IDEyMC41LAogICAgICAidGV4dCI6ICJsaW1pdGVkIHRpbWUtLT5cbnJ1biBzaW1wbGUiLAogICAgICAicmFkaXVzWCI6IDg0Ljc2Nzk0NDMzNTkzNzUsCiAgICAgICJyYWRpdXNZIjogMzguNCwKICAgICAgImZvbnRTaXplIjogMTYsCiAgICAgICJjb2xvciI6ICIjODdDRUVCIiwKICAgICAgImZvbnQiOiAiUG9wcGlucywgc2Fucy1zZXJpZiIKICAgIH0sCiAgICB7CiAgICAgICJ0eXBlIjogImJ1YmJsZSIsCiAgICAgICJpZCI6IDE3NjUyOTQ4MDkyOTYuMTExNiwKICAgICAgIngiOiAxNTcuNSwKICAgICAgInkiOiA1Ni41LAogICAgICAidGV4dCI6ICJNdXN0IHdvcmsgdy9cbnBlb3BsZS10ZWNoIG9ubHkiLAogICAgICAicmFkaXVzWCI6IDkyLjkyNzk0MDM2ODY1MjM0LAogICAgICAicmFkaXVzWSI6IDM4LjQsCiAgICAgICJmb250U2l6ZSI6IDE2LAogICAgICAiY29sb3IiOiAiIzg3Q0VFQiIsCiAgICAgICJmb250IjogIlBvcHBpbnMsIHNhbnMtc2VyaWYiLAogICAgICAiY29tbWVudCI6ICJUaGlzIGVuYWJsZXMgdGhlIHNwcmluZyBwcm90b3R5cGUiCiAgICB9LAogICAgewogICAgICAidHlwZSI6ICJidWJibGUiLAogICAgICAiaWQiOiAxNzY1Mjk0OTA5MzIwLjIxNTMsCiAgICAgICJ4IjogLTE1Mi4wNDgyNjEyMTE3ODM0OCwKICAgICAgInkiOiA1NS42MDU1Nzc0NzEwMDgxMjUsCiAgICAgICJ0ZXh0IjogIkFzIGEgcGVyc29uIGlzXG50byB0aGUgZ3JvdXAsXG5zbyB0aGUgZ3JvdXAgaXNcbnRvIGxhcmdlciBncm91cHMiLAogICAgICAicmFkaXVzWCI6IDg4LjIzMTkyNTk2NDM1NTQ3LAogICAgICAicmFkaXVzWSI6IDU3LjU5OTk5OTk5OTk5OTk5NCwKICAgICAgImZvbnRTaXplIjogMTYsCiAgICAgICJjb2xvciI6ICIjODdDRUVCIiwKICAgICAgImZvbnQiOiAiUG9wcGlucywgc2Fucy1zZXJpZiIKICAgIH0sCiAgICB7CiAgICAgICJ0eXBlIjogImJ1YmJsZSIsCiAgICAgICJpZCI6IDE3NjUyOTQ5ODg3MTQuODg2LAogICAgICAieCI6IC03Ny41MDQwNzc0ODE5NTQ5OCwKICAgICAgInkiOiAzMjEuMTM4OTcyNTU2NDM1NCwKICAgICAgInRleHQiOiAiU292ZXJlaWduIEFJIiwKICAgICAgInJhZGl1c1giOiA3My4xOTk5NTg4MDEyNjk1MywKICAgICAgInJhZGl1c1kiOiAyOC43OTk5OTk5OTk5OTk5OTcsCiAgICAgICJmb250U2l6ZSI6IDE2LAogICAgICAiY29sb3IiOiAiIzg3Q0VFQiIsCiAgICAgICJmb250IjogIlBvcHBpbnMsIHNhbnMtc2VyaWYiCiAgICB9CiAgXSwKICAiY29ubmVjdGlvbnMiOiBbXSwKICAic2NlbmVzIjogW10sCiAgInRpbWVzdGFtcCI6ICIyMDI1LTEyLTA5VDE1OjQzOjM0LjI4N1oiLAogICJ2ZXJzaW9uIjogIjEuMCIKfQ==';
        
        // Load embedded data on startup
        function loadEmbeddedData() {
            try {
                const decodedData = decodeURIComponent(escape(atob(embeddedDataEncoded)));
                const data = JSON.parse(decodedData);
                if (data && data.elements && data.connections) {
                    console.log('Loading embedded mindmap data...');
                    elements = data.elements;
                    connections = data.connections;
                    if (data.scenes) {
                        scenes = data.scenes;
                        updateScenesList();
                        updateScenesButtons();
                    }
                    
                    // Ensure all connections have IDs
                    connections.forEach(c => { if (!c.id) c.id = Date.now() + Math.random(); });
                    selectedElement = null;
                    
                    // Load any images in the mindmap
                    const imagePromises = elements.filter(el => el.type === 'image').map(el => {
                        return loadImage(el.url).then(img => {
                            // Update natural dimensions if not already set
                            if (!el.naturalWidth || !el.naturalHeight) {
                                el.naturalWidth = img.naturalWidth;
                                el.naturalHeight = img.naturalHeight;
                            }
                        }).catch(error => {
                            console.warn('Failed to load image during bundle load:', el.url, error);
                        });
                    });
                    
                    // Update the title to indicate it's a bundled file
                    document.title = 'Mind Mapper - ' + (data.timestamp ? new Date(data.timestamp).toLocaleDateString() : 'Bundled');
                    
                    console.log('Embedded mindmap loaded successfully');
                    
                    // Draw after images are loaded
                    Promise.all(imagePromises).finally(() => {
                        draw();
                    });
                }
            } catch (error) {
                console.error('Error loading embedded data:', error);
            }
        }
        
        // Call load function after DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', loadEmbeddedData);
        } else {
            loadEmbeddedData();
        }
        
        // --- Original Mindmap Code ---

        // Get references to DOM elements
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const contextMenu = document.getElementById('contextMenu');
        const helpModal = document.getElementById('helpModal');
        const commentModal = document.getElementById('commentModal');
        const undoBtn = document.getElementById('undoBtn');
        const redoBtn = document.getElementById('redoBtn');
        const textInput = document.getElementById('textInput');

        // Core data structures
        let elements = [];        // Array of all mindmap elements (bubbles, text, and images)
        let connections = [];     // Array of connections between bubbles
        
        // Undo/redo system
        let history = [];         // Array of previous states
        let historyIndex = -1;    // Current position in history

        // Camera/viewport settings
        let cameraOffset = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
        let cameraZoom = 1;
        const MAX_ZOOM = 5;
        const MIN_ZOOM = 0.1;
        const SCROLL_SENSITIVITY = 0.0005;

        // Interaction state variables
        let isDragging = false;           // Whether user is currently dragging
        let dragStart = { x: 0, y: 0 };   // Starting position of drag
        let draggedElement = null;        // Element being dragged
        let selectedElement = null;       // Currently selected element
        let contextElement = null;        // Element for context menu
        let clipboard = null;             // Copied element for paste operations
        let connectionStartElement = null; // Element being connected from
        let lastMousePosition = { x: 0, y: 0 }; // Last known mouse position
        let textInputWorldPosition = null; // World position for new text input
        let resizingElement = null;       // Element being resized
        let resizeHandle = null;          // Which corner is being resized
        let imageCache = new Map();       // Cache for loaded images
        
        // Scene management variables
        let scenes = [];                  // Array of saved scenes
        let currentSceneIndex = -1;       // Current scene index
        let isPlayingScenes = false;      // Whether scenes are currently playing
        let playTimeout = null;           // Timeout for scene transitions
        let countdownInterval = null;     // Interval for countdown timer
        let countdownSeconds = 5;         // Current countdown value
        let isAnimating = false;          // Whether camera is currently animating
        let animationStartTime = 0;       // Start time of current animation
        let animationDuration = 1000;     // Animation duration in milliseconds
        let animationStartCamera = null;  // Starting camera state
        let animationTargetCamera = null; // Target camera state
        
        // Save state tracking
        let hasUnsavedChanges = false;    // Track if there are unsaved changes
        let lastSavedState = null;        // Store the last saved state for comparison
        let newMindmapPending = false;    // Track if a new mindmap is waiting for save completion

        // Color palette for bubbles
        const colors = ['#87CEEB', '#98FB98', '#FFD700', '#FFA07A', '#DDA0DD', '#F08080', 'transparent'];
        let nextBubbleColor = colors[0];

        // Force-directed layout variables
        let originalPositions = []; // Store original positions for revert
        let isLayoutRunning = false;
        let animationId = null;
        const FORCE_LAYOUT_CONFIG = {
            repulsionStrength: 50000,   // Force between nodes (increased 10x)
            attractionStrength: 500.0,  // Force along edges (increased 10x from 50.0)
            unconnectedRepulsionStrength: 20000, // Much stronger repulsion between unconnected elements (doubled again)
            damping: 0.98,              // Velocity damping (increased to allow longer movement)
            maxVelocity: 500,           // Maximum velocity per step (increased for longer movement)
            iterations: 500,            // Number of iterations per frame (increased to 500)
            stopThreshold: 2.0          // Stop when average velocity is below this (reduced to continue longer)
        };

        // --- Setup Function ---
        // Initializes the mindmap with default content and sets up the canvas
        function setup() {
            console.log('Setup function called');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            console.log('Setting up color palette...');
            setupColorPalette();
            
            // Create initial content if mindmap is empty
            if (elements.length === 0) {
                console.log('Creating initial elements...');
                 const initialText = 'Central Idea';
                 const defaultFontSize = 16;
                 const radii = calculateBubbleRadii(initialText, defaultFontSize);
                 elements.push({ 
                     type: 'bubble', id: Date.now(), x: 0, y: 0, text: initialText, 
                     radiusX: radii.radiusX, radiusY: radii.radiusY, color: nextBubbleColor, fontSize: defaultFontSize,
                     comment: 'This is a hidden note. Right-click to view or edit.'
                 });
                 elements.push({ type: 'text', id: Date.now() + 1, x: -250, y: -150, text: 'Project Header', font: '24px Montserrat', color: '#333' });
            }
            
            console.log('Drawing initial state...');
            draw();
            
            console.log('Saving initial state...');
            saveState();
            
            // Initialize scenes UI
            updateScenesList();
            updateScenesButtons();
            
            console.log('Setup complete');
            
            // Debug: Check if controls are visible
            const controls = document.getElementById('controls');
            const helpBtn = document.getElementById('helpBtn');
            console.log('Controls element exists:', !!controls);
            console.log('Help button exists:', !!helpBtn);
            if (controls) {
                console.log('Controls display style:', controls.style.display);
                console.log('Controls visibility:', controls.style.visibility);
                console.log('Controls z-index:', controls.style.zIndex);
            }
        }

        // --- Drawing Function ---
        // Main rendering function that draws all elements and connections
        function draw() {
            // Reset canvas size to match window
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            // Apply camera transformations
            ctx.save();
            ctx.translate(cameraOffset.x, cameraOffset.y);
            ctx.scale(cameraZoom, cameraZoom);

            // Draw all connections between bubbles
            connections.forEach(conn => {
                const from = elements.find(el => el.id === conn.from);
                const to = elements.find(el => el.id === conn.to);
                if (from && to) {
                    const isSelected = selectedElement && selectedElement.id === conn.id;
                    ctx.beginPath();
                    ctx.moveTo(from.x, from.y);
                    ctx.lineTo(to.x, to.y);
                    ctx.strokeStyle = isSelected ? '#007bff' : '#999';
                    ctx.lineWidth = isSelected ? (conn.weight || 1) + 2 : (conn.weight || 1);
                    ctx.setLineDash([]);
                    ctx.stroke();

                    // Draw connection labels if they exist
                    if (conn.label) {
                        const midX = (from.x + to.x) / 2;
                        const midY = (from.y + to.y) / 2;
                        ctx.font = '12px Poppins, sans-serif';
                        const textWidth = ctx.measureText(conn.label).width;
                        
                        // Draw semi-transparent background
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)'; // 80% opacity white
                        ctx.fillRect(midX - textWidth / 2 - 4, midY - 10, textWidth + 8, 20);
                        
                        // Draw text with better contrast
                        ctx.fillStyle = '#333';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(conn.label, midX, midY);
                    }
                }
            });
            
            // Draw preview connection line when connecting bubbles
            if (connectionStartElement) {
                const worldMousePos = screenToWorld(lastMousePosition.x, lastMousePosition.y);
                ctx.beginPath();
                ctx.moveTo(connectionStartElement.x, connectionStartElement.y);
                ctx.lineTo(worldMousePos.x, worldMousePos.y);
                ctx.strokeStyle = '#007bff';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // Draw all elements (bubbles, text, and images)
            elements.forEach(el => {
                const isSelected = selectedElement && selectedElement.id === el.id;
                ctx.fillStyle = el.color;
                ctx.strokeStyle = isSelected ? '#007bff' : '#333';
                ctx.lineWidth = isSelected ? 4 : 2;

                if (el.type === 'bubble') {
                    // Draw bubble as ellipse
                    ctx.beginPath();
                    ctx.ellipse(el.x, el.y, el.radiusX, el.radiusY, 0, 0, 2 * Math.PI);
                    if (el.color !== 'transparent') {
                        ctx.fill();
                    }
                    ctx.stroke();
                    
                    // Draw bubble text
                    ctx.fillStyle = '#000';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.font = `${el.fontSize}px ${el.font || 'Poppins'}`;
                    
                    // Handle multi-line text
                    const lines = el.text.split('\n');
                    const lineHeight = el.fontSize * 1.2;
                    const totalHeight = lines.length * lineHeight;
                    const startY = el.y - (totalHeight - lineHeight) / 2;
                    
                    lines.forEach((line, index) => {
                        ctx.fillText(line, el.x, startY + index * lineHeight);
                    });

                    // Draw comment indicator if bubble has a comment
                    if (el.comment) {
                        ctx.fillStyle = '#007bff';
                        ctx.beginPath();
                        ctx.arc(el.x + el.radiusX - 10, el.y - el.radiusY + 10, 5, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.fillStyle = 'white';
                        ctx.font = '8px Poppins';
                        ctx.fillText('...', el.x + el.radiusX - 10, el.y - el.radiusY + 11);
                    }

                    // Draw link indicator if bubble has a link
                    if (el.link) {
                        ctx.fillStyle = '#28a745'; // Green color for links
                        ctx.beginPath();
                        ctx.arc(el.x + el.radiusX - 10, el.y - el.radiusY + 20, 5, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.fillStyle = 'white';
                        ctx.font = '8px Poppins';
                        ctx.fillText('üîó', el.x + el.radiusX - 10, el.y - el.radiusY + 21);
                    }

                } else if (el.type === 'text') {
                    // Draw text annotation
                    ctx.font = el.font;
                    ctx.textAlign = 'left';
                    ctx.textBaseline = 'top';
                    ctx.fillText(el.text, el.x, el.y);
                    if (isSelected) {
                         const textWidth = ctx.measureText(el.text).width;
                         const textHeight = parseInt(el.font, 10);
                         ctx.strokeRect(el.x - 2, el.y - 2, textWidth + 4, textHeight + 4);
                    }
                } else if (el.type === 'image') {
                    // Draw image background/border only if selected
                    if (isSelected) {
                        ctx.fillStyle = '#f8f9fa';
                        ctx.fillRect(el.x, el.y, el.width, el.height);
                        ctx.strokeRect(el.x, el.y, el.width, el.height);
                    }
                    
                    // Try to draw the actual image
                    const cachedImage = imageCache.get(el.url);
                    if (cachedImage) {
                        try {
                            ctx.drawImage(cachedImage, el.x, el.y, el.width, el.height);
                        } catch (error) {
                            console.warn('Error drawing image:', error);
                            // Fall back to placeholder
                            drawImagePlaceholder(ctx, el);
                        }
                    } else {
                        // Draw placeholder while image is loading
                        drawImagePlaceholder(ctx, el);
                        
                        // Try to load the image if not already loading
                        if (!el.loading) {
                            el.loading = true;
                            loadImage(el.url).then(img => {
                                el.loading = false;
                                draw(); // Redraw to show the loaded image
                            }).catch(error => {
                                el.loading = false;
                                console.warn('Failed to load image:', el.url, error);
                            });
                        }
                    }
                    
                    // Draw comment indicator if image has a comment
                    if (el.comment) {
                        ctx.fillStyle = '#007bff';
                        ctx.beginPath();
                        ctx.arc(el.x + el.width - 10, el.y + 10, 5, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.fillStyle = 'white';
                        ctx.font = '8px Poppins';
                        ctx.fillText('...', el.x + el.width - 10, el.y + 11);
                    }

                    // Draw link indicator if image has a link (and it's different from the image URL)
                    if (el.link && el.link !== el.url) {
                        ctx.fillStyle = '#28a745'; // Green color for links
                        ctx.beginPath();
                        ctx.arc(el.x + el.width - 10, el.y + 20, 5, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.fillStyle = 'white';
                        ctx.font = '8px Poppins';
                        ctx.fillText('üîó', el.x + el.width - 10, el.y + 21);
                    }

                    // Draw resize handles if selected
                    if (isSelected) {
                        const handleSize = 8;
                        ctx.fillStyle = '#007bff';
                        
                        // Top-left corner
                        ctx.fillRect(el.x - handleSize/2, el.y - handleSize/2, handleSize, handleSize);
                        // Top-right corner
                        ctx.fillRect(el.x + el.width - handleSize/2, el.y - handleSize/2, handleSize, handleSize);
                        // Bottom-left corner
                        ctx.fillRect(el.x - handleSize/2, el.y + el.height - handleSize/2, handleSize, handleSize);
                        // Bottom-right corner
                        ctx.fillRect(el.x + el.width - handleSize/2, el.y + el.height - handleSize/2, handleSize, handleSize);
                    }
                }
            });

            ctx.restore();
        }

        // --- History Management Functions ---
        // Saves current state for undo/redo functionality
        function saveState() {
            try {
                // Remove any future history if we're not at the end
                history = history.slice(0, historyIndex + 1);
                const currentState = {
                    elements: JSON.parse(JSON.stringify(elements)),
                    connections: JSON.parse(JSON.stringify(connections)),
                    originalPositions: JSON.parse(JSON.stringify(originalPositions)),
                    scenes: JSON.parse(JSON.stringify(scenes))
                };
                history.push(currentState);
                historyIndex++;
                
                // Mark as having unsaved changes
                hasUnsavedChanges = true;
                
                // Safe update of UI elements
                try {
                    updateUndoRedoButtons();
                } catch (uiError) {
                    console.warn('Could not update undo/redo buttons:', uiError);
                }
                
                // Update revert button state
                try {
                    const revertBtn = document.getElementById('revertLayoutBtn');
                    if (revertBtn) {
                        revertBtn.disabled = originalPositions.length === 0;
                    }
                } catch (revertError) {
                    console.warn('Could not update revert button:', revertError);
                }
            } catch (error) {
                console.error('Error in saveState:', error);
            }
        }

        // Loads a specific state from history
        function loadState(state) {
            elements = JSON.parse(JSON.stringify(state.elements));
            connections = JSON.parse(JSON.stringify(state.connections));
            if (state.scenes) {
                scenes = JSON.parse(JSON.stringify(state.scenes));
                updateScenesList();
                updateScenesButtons();
            }
            selectedElement = null;
            draw();
        }

        // Undo/redo functions
        function undo() { if (historyIndex > 0) { historyIndex--; loadState(history[historyIndex]); updateUndoRedoButtons(); } }
        function redo() { if (historyIndex < history.length - 1) { historyIndex++; loadState(history[historyIndex]); updateUndoRedoButtons(); } }
        function updateUndoRedoButtons() { 
            try {
                if (undoBtn) undoBtn.disabled = historyIndex <= 0; 
                if (redoBtn) redoBtn.disabled = historyIndex >= history.length - 1; 
            } catch (error) {
                console.warn('Could not update undo/redo buttons:', error);
            }
        }
        
        // Check if there are unsaved changes
        function checkForUnsavedChanges() {
            return hasUnsavedChanges;
        }
        
        // Clear unsaved changes flag (called after successful save)
        function clearUnsavedChanges() {
            hasUnsavedChanges = false;
        }
        
        // Start a new mindmap
        function startNewMindmap() {
            if (checkForUnsavedChanges()) {
                const shouldSave = confirm('You have unsaved changes. Would you like to save before starting a new mindmap?');
                if (shouldSave) {
                    // Set flag to create new mindmap after save
                    newMindmapPending = true;
                    // Trigger save functionality
                    const saveBtn = document.getElementById('saveBtn');
                    if (saveBtn) {
                        saveBtn.click();
                        return; // Don't proceed with new mindmap yet
                    }
                } else {
                    // User cancelled the save prompt, don't create new mindmap
                    return;
                }
            }
            
            // Only proceed if we get here (no unsaved changes or user didn't cancel)
            createNewMindmap();
        }
        
        // Actually create the new mindmap (separate function to avoid recursion issues)
        function createNewMindmap() {
            // Clear the mindmap
            elements = [];
            connections = [];
            scenes = [];
            currentSceneIndex = -1;
            history = [];
            historyIndex = -1;
            originalPositions = [];
            selectedElement = null;
            contextElement = null;
            clipboard = null;
            connectionStartElement = null;
            
            // Reset camera
            cameraOffset = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
            cameraZoom = 1;
            
            // Clear unsaved changes
            clearUnsavedChanges();
            
            // Update UI
            updateUndoRedoButtons();
            updateScenesList();
            updateScenesButtons();
            
            // Redraw
            draw();
            
            console.log('New mindmap started');
        }

        // --- Utility Functions ---
        // Calculates bubble dimensions based on text content
        function calculateBubbleRadii(text, fontSize, font = 'Poppins') {
            ctx.font = `${fontSize}px ${font}`;
            const lines = text.split('\n');
            let maxWidth = 0;
            
            // Find the widest line
            lines.forEach(line => {
                const textMetrics = ctx.measureText(line);
                maxWidth = Math.max(maxWidth, textMetrics.width);
            });
            
            const paddingX = fontSize * 1.5;
            const paddingY = fontSize * 1.2;
            const lineHeight = fontSize * 1.2;
            const totalHeight = lines.length * lineHeight;
            
            return { 
                radiusX: maxWidth / 2 + paddingX, 
                radiusY: totalHeight / 2 + paddingY 
            };
        }

        // Coordinate conversion functions
        function getEventLocation(e) { return { x: e.clientX, y: e.clientY }; }
        function screenToWorld(x, y) { return { x: (x - cameraOffset.x) / cameraZoom, y: (y - cameraOffset.y) / cameraZoom }; }
        function worldToScreen(x, y) { return { x: x * cameraZoom + cameraOffset.x, y: y * cameraZoom + cameraOffset.y }; }

        // Finds element at given screen coordinates
        function getElementAtPosition(x, y) {
            const worldPos = screenToWorld(x, y);
            // Check elements in reverse order (top to bottom)
            for (let i = elements.length - 1; i >= 0; i--) {
                const el = elements[i];
                if (el.type === 'bubble') {
                    // Check if point is inside ellipse
                    const dx = worldPos.x - el.x;
                    const dy = worldPos.y - el.y;
                    if ((dx * dx) / (el.radiusX * el.radiusX) + (dy * dy) / (el.radiusY * el.radiusY) <= 1) return el;
                } else if (el.type === 'text') {
                    // Check if point is inside text bounding box
                    ctx.font = el.font;
                    const textWidth = ctx.measureText(el.text).width;
                    const textHeight = parseInt(el.font, 10);
                    if (worldPos.x > el.x && worldPos.x < el.x + textWidth && worldPos.y > el.y && worldPos.y < el.y + textHeight) return el;
                } else if (el.type === 'image') {
                    // Check if point is inside image rectangle
                    if (worldPos.x > el.x && worldPos.x < el.x + el.width && worldPos.y > el.y && worldPos.y < el.y + el.height) return el;
                }
            }
            return null;
        }

        // Finds connection line at given screen coordinates
        function getEdgeAtPosition(x, y) {
            const worldPos = screenToWorld(x, y);
            const threshold = 5 / cameraZoom;
            for (const conn of connections) {
                const from = elements.find(el => el.id === conn.from);
                const to = elements.find(el => el.id === conn.to);
                if (!from || !to) continue;
                
                // Calculate closest point on line segment
                const dx = to.x - from.x; const dy = to.y - from.y;
                const lenSq = dx * dx + dy * dy;
                if (lenSq === 0) continue;
                let t = ((worldPos.x - from.x) * dx + (worldPos.y - from.y) * dy) / lenSq;
                t = Math.max(0, Math.min(1, t));
                const closestX = from.x + t * dx; const closestY = from.y + t * dy;
                const distSq = (worldPos.x - closestX) ** 2 + (worldPos.y - closestY) ** 2;
                if (distSq < threshold ** 2) return conn;
            }
            return null;
        }

        // Finds resize handle at given screen coordinates
        function getResizeHandleAtPosition(x, y) {
            if (!selectedElement || selectedElement.type !== 'image') return null;
            
            const worldPos = screenToWorld(x, y);
            const handleSize = 8 / cameraZoom;
            const el = selectedElement;
            
            // Check each corner
            if (Math.abs(worldPos.x - el.x) <= handleSize/2 && Math.abs(worldPos.y - el.y) <= handleSize/2) {
                return 'top-left';
            }
            if (Math.abs(worldPos.x - (el.x + el.width)) <= handleSize/2 && Math.abs(worldPos.y - el.y) <= handleSize/2) {
                return 'top-right';
            }
            if (Math.abs(worldPos.x - el.x) <= handleSize/2 && Math.abs(worldPos.y - (el.y + el.height)) <= handleSize/2) {
                return 'bottom-left';
            }
            if (Math.abs(worldPos.x - (el.x + el.width)) <= handleSize/2 && Math.abs(worldPos.y - (el.y + el.height)) <= handleSize/2) {
                return 'bottom-right';
            }
            
            return null;
        }

        // Deletes an element or connection
        function deleteElement(element) {
            if (!element) return;
            if (element.id && !element.from) { // It's a node/element
                 elements = elements.filter(el => el.id !== element.id);
                 connections = connections.filter(conn => conn.from !== element.id && conn.to !== element.id);
            } else if (element.from && element.to) { // It's a connection
                connections = connections.filter(c => c.id !== element.id);
            }
            if (selectedElement === element) selectedElement = null;
            draw();
            saveState();
        }

        // Hides the context menu
        function hideContextMenu() {
            contextMenu.style.display = 'none';
            contextElement = null;
        }
        
        // Sets up the color palette UI
        function setupColorPalette() {
            const palette = document.getElementById('colorPalette');
            palette.innerHTML = '';
            colors.forEach((color) => {
                const swatch = document.createElement('div');
                swatch.className = 'color-swatch';
                if (color === 'transparent') {
                    swatch.style.background = 'linear-gradient(45deg, #ccc 25%, transparent 25%), linear-gradient(-45deg, #ccc 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #ccc 75%), linear-gradient(-45deg, transparent 75%, #ccc 75%)';
                    swatch.style.backgroundSize = '8px 8px';
                    swatch.style.backgroundPosition = '0 0, 0 4px, 4px -4px, -4px 0px';
                    swatch.title = 'Transparent';
                } else {
                    swatch.style.backgroundColor = color;
                    swatch.title = color;
                }
                swatch.dataset.color = color;
                if (color === nextBubbleColor) swatch.classList.add('selected');
                palette.appendChild(swatch);
            });
        }
        
        // Zooms to fit all content in the viewport
        function zoomToExtents() {
            if (elements.length === 0) {
                cameraOffset = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
                cameraZoom = 1;
                draw();
                return;
            }
            
            // Calculate bounding box of all elements
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            elements.forEach(el => {
                let elMinX, elMinY, elMaxX, elMaxY;
                if (el.type === 'bubble') {
                    elMinX = el.x - el.radiusX; elMinY = el.y - el.radiusY;
                    elMaxX = el.x + el.radiusX; elMaxY = el.y + el.radiusY;
                } else if (el.type === 'text') {
                    ctx.font = el.font;
                    const textWidth = ctx.measureText(el.text).width;
                    const textHeight = parseInt(el.font, 10);
                    elMinX = el.x; elMinY = el.y; elMaxX = el.x + textWidth; elMaxY = el.y + textHeight;
                } else if (el.type === 'image') {
                    elMinX = el.x; elMinY = el.y; elMaxX = el.x + el.width; elMaxY = el.y + el.height;
                }
                if (elMinX < minX) minX = elMinX; if (elMinY < minY) minY = elMinY;
                if (elMaxX > maxX) maxX = elMaxX; if (elMaxY > maxY) maxY = elMaxY;
            });
            
            // Calculate zoom level to fit content with extra padding for UI elements
            const contentWidth = maxX - minX; const contentHeight = maxY - minY;
            const padding = 100; // Increased padding to account for UI elements
            const zoomX = (canvas.width - padding * 2) / contentWidth;
            const zoomY = (canvas.height - padding * 2) / contentHeight;
            cameraZoom = Math.min(zoomX, zoomY, MAX_ZOOM);
            cameraZoom = Math.max(cameraZoom, MIN_ZOOM);
            
            // Apply a small zoom-out factor for extra breathing room
            cameraZoom *= 0.9;
            
            // Center the content
            const contentCenterX = minX + contentWidth / 2;
            const contentCenterY = minY + contentHeight / 2;
            cameraOffset.x = canvas.width / 2 - contentCenterX * cameraZoom;
            cameraOffset.y = canvas.height / 2 - contentCenterY * cameraZoom;
            draw();
        }

        // --- Force-Directed Layout Functions ---
        // Stores original positions for revert functionality
        function storeOriginalPositions() {
            originalPositions = elements.map(el => ({ id: el.id, x: el.x, y: el.y }));
        }

        // Reverts to original positions
        function revertToOriginalPositions() {
            originalPositions.forEach(pos => {
                const element = elements.find(el => el.id === pos.id);
                if (element) {
                    element.x = pos.x;
                    element.y = pos.y;
                }
            });
            draw();
            saveState();
        }

        // Draws a placeholder for images that are loading or failed to load
        function drawImagePlaceholder(ctx, el) {
            // Draw image icon
            ctx.fillStyle = '#6c757d';
            ctx.font = '16px Poppins';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('üñºÔ∏è', el.x + el.width / 2, el.y + el.height / 2 - 10);
            
            // Draw image URL text (truncated)
            const urlText = el.url.length > 20 ? el.url.substring(0, 20) + '...' : el.url;
            ctx.fillStyle = '#495057';
            ctx.font = '12px Poppins';
            ctx.fillText(urlText, el.x + el.width / 2, el.y + el.height / 2 + 10);
        }

        // Calculates mass for a bubble based on its size
        function calculateMass(element) {
            if (element.type === 'bubble') {
                // Mass based on bubble area (œÄ * radiusX * radiusY)
                const mass = Math.PI * element.radiusX * element.radiusY;
                console.log(`Element ${element.id} (${element.text}): mass = ${mass.toFixed(2)}`);
                return mass;
            } else if (element.type === 'text') {
                // Text elements have much smaller mass (less repulsive force)
                console.log(`Text element ${element.id} (${element.text}): mass = 5`);
                return 5; // Reduced from 25 to 5 for much less repulsive force
            } else if (element.type === 'image') {
                // Image elements have mass based on their area
                const mass = element.width * element.height;
                console.log(`Image element ${element.id}: mass = ${mass.toFixed(2)}`);
                return mass;
            }
        }

        // Calculates stiffness for an edge based on its weight
        function calculateStiffness(connection) {
            return (connection.weight || 1) * 0.1;
        }

        // Calculates ideal length for an edge based on connected bubble sizes
        function calculateIdealLength(connection) {
            const from = elements.find(el => el.id === connection.from);
            const to = elements.find(el => el.id === connection.to);
            if (!from || !to) return 100;
            
            // Ideal length based on element sizes
            let fromSize, toSize;
            if (from.type === 'bubble') {
                fromSize = Math.max(from.radiusX, from.radiusY);
            } else if (from.type === 'image') {
                fromSize = Math.max(from.width, from.height) / 2;
            } else {
                fromSize = 20;
            }
            
            if (to.type === 'bubble') {
                toSize = Math.max(to.radiusX, to.radiusY);
            } else if (to.type === 'image') {
                toSize = Math.max(to.width, to.height) / 2;
            } else {
                toSize = 20;
            }
            
            return fromSize + toSize + 50; // Minimum distance between element edges
        }

        // Runs one step of the force-directed layout algorithm
        function runForceLayoutStep() {
            const velocities = new Map(); // Store velocities for each element
            
            // Initialize velocities
            elements.forEach(el => {
                velocities.set(el.id, { x: 0, y: 0 });
            });

            let totalRepulsiveForce = 0;
            let totalAttractiveForce = 0;

            // Calculate repulsive forces between all pairs of elements
            for (let i = 0; i < elements.length; i++) {
                for (let j = i + 1; j < elements.length; j++) {
                    const el1 = elements[i];
                    const el2 = elements[j];
                    
                    const dx = el2.x - el1.x;
                    const dy = el2.y - el1.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance > 0) {
                        // Check if elements are connected
                        const areConnected = connections.some(conn => 
                            (conn.from === el1.id && conn.to === el2.id) || 
                            (conn.from === el2.id && conn.to === el1.id)
                        );
                        
                        // Use different repulsion strength based on connection
                        const repulsionStrength = areConnected ? 
                            FORCE_LAYOUT_CONFIG.repulsionStrength * 0.1 : // Weak repulsion for connected elements
                            FORCE_LAYOUT_CONFIG.unconnectedRepulsionStrength; // Stronger repulsion for unconnected elements
                        
                        // Repulsive force (inversely proportional to distance squared)
                        const force = repulsionStrength / (distance * distance);
                        totalRepulsiveForce += force;
                        const fx = (dx / distance) * force;
                        const fy = (dy / distance) * force;
                        
                        // Apply force based on mass (heavier elements move less)
                        const mass1 = calculateMass(el1);
                        const mass2 = calculateMass(el2);
                        
                        const vel1 = velocities.get(el1.id);
                        const vel2 = velocities.get(el2.id);
                        
                        vel1.x -= fx / mass1;
                        vel1.y -= fy / mass1;
                        vel2.x += fx / mass2;
                        vel2.y += fy / mass2;
                    }
                }
            }

            // Calculate attractive forces along connections
            connections.forEach(conn => {
                const from = elements.find(el => el.id === conn.from);
                const to = elements.find(el => el.id === conn.to);
                
                if (from && to) {
                    const dx = to.x - from.x;
                    const dy = to.y - from.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const idealLength = calculateIdealLength(conn);
                    const stiffness = calculateStiffness(conn);
                    
                    if (distance > 0) {
                        // Attractive force (proportional to distance from ideal length)
                        const force = (distance - idealLength) * stiffness * FORCE_LAYOUT_CONFIG.attractionStrength;
                        totalAttractiveForce += Math.abs(force);
                        const fx = (dx / distance) * force;
                        const fy = (dy / distance) * force;
                        
                        // Apply force based on mass
                        const massFrom = calculateMass(from);
                        const massTo = calculateMass(to);
                        
                        const velFrom = velocities.get(from.id);
                        const velTo = velocities.get(to.id);
                        
                        velFrom.x += fx / massFrom;
                        velFrom.y += fy / massFrom;
                        velTo.x -= fx / massTo;
                        velTo.y -= fy / massTo;
                    }
                }
            });

            // Apply velocities with damping and limits
            let totalVelocity = 0;
            elements.forEach(el => {
                const vel = velocities.get(el.id);
                
                // Apply damping
                vel.x *= FORCE_LAYOUT_CONFIG.damping;
                vel.y *= FORCE_LAYOUT_CONFIG.damping;
                
                // Limit maximum velocity
                const speed = Math.sqrt(vel.x * vel.x + vel.y * vel.y);
                if (speed > FORCE_LAYOUT_CONFIG.maxVelocity) {
                    vel.x = (vel.x / speed) * FORCE_LAYOUT_CONFIG.maxVelocity;
                    vel.y = (vel.y / speed) * FORCE_LAYOUT_CONFIG.maxVelocity;
                }
                
                // Update position
                el.x += vel.x;
                el.y += vel.y;
                
                totalVelocity += speed;
            });

            const avgVelocity = totalVelocity / elements.length;
            console.log(`Forces - Repulsive: ${totalRepulsiveForce.toFixed(2)}, Attractive: ${totalAttractiveForce.toFixed(2)}, Avg Velocity: ${avgVelocity.toFixed(2)}`);
            
            return avgVelocity; // Return average velocity
        }

        // Main force-directed layout animation loop
        function animateForceLayout() {
            if (!isLayoutRunning) return;
            
            let averageVelocity = 0;
            
            // Run multiple iterations per frame for better performance
            for (let i = 0; i < FORCE_LAYOUT_CONFIG.iterations; i++) {
                averageVelocity = runForceLayoutStep();
            }
            
            draw();
            
            // Continue animation if velocity is above threshold
            if (averageVelocity > FORCE_LAYOUT_CONFIG.stopThreshold) {
                animationId = requestAnimationFrame(animateForceLayout);
            } else {
                // Layout has converged
                isLayoutRunning = false;
                document.getElementById('forceLayoutBtn').disabled = false;
                document.getElementById('revertLayoutBtn').disabled = false;
                console.log('Force-directed layout completed with final velocity:', averageVelocity);
            }
        }

        // Starts the force-directed layout
        function startForceLayout() {
            if (isLayoutRunning) return;
            
            // Check if there are scenes and warn the user
            if (scenes.length > 0) {
                const warningMessage = `Warning: You have ${scenes.length} saved scene(s). Auto-layout will move elements to new positions, which may make your scene viewports inaccurate. Do you want to continue?`;
                const shouldContinue = confirm(warningMessage);
                if (!shouldContinue) {
                    return; // User cancelled
                }
            }
            
            console.log('Starting force-directed layout...');
            console.log('Elements:', elements.length, 'Connections:', connections.length);
            
            // Store original positions for revert
            storeOriginalPositions();
            
            // Disable buttons during layout
            document.getElementById('forceLayoutBtn').disabled = true;
            document.getElementById('revertLayoutBtn').disabled = true;
            
            isLayoutRunning = true;
            animateForceLayout();
        }

        // Stops the force-directed layout
        function stopForceLayout() {
            isLayoutRunning = false;
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            document.getElementById('forceLayoutBtn').disabled = false;
            document.getElementById('revertLayoutBtn').disabled = false;
        }

        // --- Element Creation Functions ---
        // Creates a new bubble at the specified position
        function createBubble(text, position) {
            const defaultFontSize = 16;
            const bubbleFont = 'Poppins, sans-serif';
            const radii = calculateBubbleRadii(text, defaultFontSize, bubbleFont);
            elements.push({
                type: 'bubble', id: Date.now() + Math.random(), x: position.x, y: position.y, text: text,
                radiusX: radii.radiusX, radiusY: radii.radiusY, fontSize: defaultFontSize,
                color: nextBubbleColor, font: bubbleFont
            });
            draw();
            saveState();
        }

        // Creates a new text annotation at the specified position
        function createAnnotation(text, position) {
            elements.push({
                type: 'text', id: Date.now() + Math.random(), x: position.x, y: position.y, text: text,
                font: '20px "Open Sans", sans-serif', color: '#555'
            });
            draw();
            saveState();
        }

        // Loads an image and caches it
        function loadImage(url) {
            return new Promise((resolve, reject) => {
                if (imageCache.has(url)) {
                    resolve(imageCache.get(url));
                    return;
                }
                
                const img = new Image();
                img.crossOrigin = 'anonymous'; // Try to handle CORS
                img.onload = () => {
                    imageCache.set(url, img);
                    resolve(img);
                };
                img.onerror = () => {
                    console.warn('Failed to load image:', url);
                    reject(new Error('Failed to load image'));
                };
                img.src = url;
            });
        }

        // Scene management functions
        function createScene(name = null) {
            const sceneName = name || `Scene ${scenes.length + 1}`;
            const scene = {
                id: Date.now() + Math.random(),
                name: sceneName,
                cameraOffset: { x: cameraOffset.x, y: cameraOffset.y },
                cameraZoom: cameraZoom
            };
            scenes.push(scene);
            updateScenesList();
            updateScenesButtons();
            return scene;
        }

        function removeScene(index) {
            if (index >= 0 && index < scenes.length) {
                scenes.splice(index, 1);
                if (currentSceneIndex >= scenes.length) {
                    currentSceneIndex = scenes.length - 1;
                }
                updateScenesList();
                updateScenesButtons();
            }
        }

        function selectScene(index) {
            if (index >= 0 && index < scenes.length) {
                currentSceneIndex = index;
                updateScenesList();
                updateScenesButtons();
                
                // Smoothly transition to the selected scene
                const selectedScene = scenes[index];
                animateToScene(selectedScene);
            }
        }

        function updateScenesList() {
            const scenesList = document.getElementById('scenesList');
            scenesList.innerHTML = '';
            
            scenes.forEach((scene, index) => {
                const sceneItem = document.createElement('div');
                sceneItem.className = `scene-item ${index === currentSceneIndex ? 'selected' : ''}`;
                sceneItem.onclick = () => selectScene(index);
                sceneItem.ondblclick = (e) => {
                    e.stopPropagation();
                    editSceneName(index, sceneItem.querySelector('.scene-name'));
                };
                
                const sceneName = document.createElement('div');
                sceneName.className = 'scene-name';
                sceneName.textContent = scene.name;
                sceneName.ondblclick = (e) => {
                    e.stopPropagation();
                    editSceneName(index, sceneName);
                };
                
                const editIcon = document.createElement('span');
                editIcon.className = 'scene-edit-icon';
                editIcon.textContent = '‚úèÔ∏è';
                editIcon.onclick = (e) => {
                    e.stopPropagation();
                    editSceneName(index, sceneName);
                };
                
                sceneItem.appendChild(sceneName);
                sceneItem.appendChild(editIcon);
                scenesList.appendChild(sceneItem);
            });
        }

        function updateScenesButtons() {
            const removeBtn = document.getElementById('removeSceneBtn');
            const playBtn = document.getElementById('playScenesBtn');
            const largePlayBtn = document.getElementById('largePlayBtn');
            const largeStopBtn = document.getElementById('largeStopBtn');
            
            removeBtn.disabled = scenes.length === 0 || currentSceneIndex === -1;
            playBtn.disabled = scenes.length < 2;
            largePlayBtn.disabled = scenes.length < 2;
            
            // Show/hide large buttons based on play state
            if (isPlayingScenes) {
                largePlayBtn.style.display = 'none';
                largeStopBtn.style.display = 'inline-block';
            } else {
                largePlayBtn.style.display = 'inline-block';
                largeStopBtn.style.display = 'none';
            }
        }

        function editSceneName(index, element) {
            const scene = scenes[index];
            const input = document.createElement('input');
            input.type = 'text';
            input.value = scene.name;
            input.className = 'scene-name editing';
            
            input.onblur = () => {
                scene.name = input.value.trim() || `Scene ${index + 1}`;
                element.textContent = scene.name;
                element.className = 'scene-name';
            };
            
            input.onkeydown = (e) => {
                if (e.key === 'Enter') {
                    input.blur();
                } else if (e.key === 'Escape') {
                    element.textContent = scene.name;
                    element.className = 'scene-name';
                }
            };
            
            element.textContent = '';
            element.appendChild(input);
            input.focus();
            input.select();
        }

        function animateToScene(targetScene) {
            if (isAnimating) return;
            
            isAnimating = true;
            animationStartTime = Date.now();
            animationStartCamera = { x: cameraOffset.x, y: cameraOffset.y, zoom: cameraZoom };
            animationTargetCamera = { x: targetScene.cameraOffset.x, y: targetScene.cameraOffset.y, zoom: targetScene.cameraZoom };
            
            function animate() {
                if (!isAnimating) return;
                
                const elapsed = Date.now() - animationStartTime;
                const progress = Math.min(elapsed / animationDuration, 1);
                
                // Easing function: slow start, accelerate, then decelerate
                const easedProgress = progress < 0.5 
                    ? 2 * progress * progress 
                    : 1 - Math.pow(-2 * progress + 2, 2) / 2;
                
                cameraOffset.x = animationStartCamera.x + (animationTargetCamera.x - animationStartCamera.x) * easedProgress;
                cameraOffset.y = animationStartCamera.y + (animationTargetCamera.y - animationStartCamera.y) * easedProgress;
                cameraZoom = animationStartCamera.zoom + (animationTargetCamera.zoom - animationStartCamera.zoom) * easedProgress;
                
                draw();
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    isAnimating = false;
                }
            }
            
            animate();
        }

        function playScenes() {
            if (isPlayingScenes || scenes.length < 2) return;
            
            isPlayingScenes = true;
            currentSceneIndex = 0;
            updateScenesList();
            updateScenesButtons();
            showCountdownTimer();
            
            function playNextScene() {
                if (!isPlayingScenes) return;
                
                if (currentSceneIndex < scenes.length) {
                    const scene = scenes[currentSceneIndex];
                    animateToScene(scene);
                    startCountdown();
                    
                    // Show scene name overlay
                    showSceneNameOverlay(scene.name);
                    
                    playTimeout = setTimeout(() => {
                        currentSceneIndex++;
                        updateScenesList();
                        playNextScene();
                    }, 5000); // 5 seconds per scene
                } else {
                    // Finished playing all scenes
                    isPlayingScenes = false;
                    currentSceneIndex = -1;
                    updateScenesList();
                    updateScenesButtons();
                    hideCountdownTimer();
                    hideSceneNameOverlay();
                }
            }
            
            playNextScene();
        }

        function stopPlayingScenes() {
            isPlayingScenes = false;
            if (playTimeout) {
                clearTimeout(playTimeout);
                playTimeout = null;
            }
            if (countdownInterval) {
                clearInterval(countdownInterval);
                countdownInterval = null;
            }
            currentSceneIndex = -1;
            updateScenesList();
            updateScenesButtons();
            hideCountdownTimer();
            hideSceneNameOverlay();
        }

        function showCountdownTimer() {
            const timer = document.getElementById('countdownTimer');
            timer.style.display = 'block';
        }

        function hideCountdownTimer() {
            const timer = document.getElementById('countdownTimer');
            timer.style.display = 'none';
        }

        function startCountdown() {
            countdownSeconds = 5;
            updateCountdownDisplay();
            
            if (countdownInterval) {
                clearInterval(countdownInterval);
            }
            
            countdownInterval = setInterval(() => {
                countdownSeconds--;
                updateCountdownDisplay();
                
                if (countdownSeconds <= 0) {
                    clearInterval(countdownInterval);
                    countdownInterval = null;
                }
            }, 1000);
        }

        function updateCountdownDisplay() {
            const countdownValue = document.getElementById('countdownValue');
            if (countdownValue) {
                countdownValue.textContent = countdownSeconds;
            }
        }
        
        function showSceneNameOverlay(sceneName) {
            const overlay = document.getElementById('sceneNameOverlay');
            const nameSpan = document.getElementById('currentSceneName');
            if (overlay && nameSpan) {
                nameSpan.textContent = sceneName;
                overlay.style.display = 'block';
            }
        }
        
        function hideSceneNameOverlay() {
            const overlay = document.getElementById('sceneNameOverlay');
            if (overlay) {
                overlay.style.display = 'none';
            }
        }

        // Creates a new image element at the specified position
        function createImage(url, position) {
            const imageElement = {
                type: 'image', id: Date.now() + Math.random(), x: position.x, y: position.y, 
                width: 200, height: 150, url: url, naturalWidth: 0, naturalHeight: 0,
                comment: '', link: url // Initialize link to the image URL
            };
            
            elements.push(imageElement);
            
            // Load the image and adjust dimensions
            loadImage(url).then(img => {
                // Calculate aspect ratio and adjust dimensions
                const aspectRatio = img.naturalWidth / img.naturalHeight;
                const maxWidth = 300;
                const maxHeight = 200;
                
                if (aspectRatio > 1) {
                    // Landscape image
                    imageElement.width = maxWidth;
                    imageElement.height = maxWidth / aspectRatio;
                } else {
                    // Portrait image
                    imageElement.height = maxHeight;
                    imageElement.width = maxHeight * aspectRatio;
                }
                
                imageElement.naturalWidth = img.naturalWidth;
                imageElement.naturalHeight = img.naturalHeight;
                
                draw();
                saveState();
            }).catch(error => {
                console.warn('Could not load image, using default size:', error);
                draw();
                saveState();
            });
        }
        
        // Converts hex color to RGB object for GEXF export
        function hexToRgb(hex) {
            if (!hex || hex === 'transparent') return { r: 150, g: 150, b: 150 }; // Default gray if no color or transparent
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? { r: parseInt(result[1], 16), g: parseInt(result[2], 16), b: parseInt(result[3], 16) } : { r: 150, g: 150, b: 150 };
        }

        // Exports the mindmap to GEXF format for use in Gephi or other graph visualization tools
        function exportToGEXF() {
            console.log('Starting GEXF export...'); // Debug
            try {
                const escapeXML = (str) => {
                    if (!str) return '';
                    return str.replace(/[<>&'"]/g, (c) => {
                        switch (c) {
                            case '<': return '&lt;'; case '>': return '&gt;'; case '&': return '&amp;';
                            case '\'': return '&apos;'; case '"': return '&quot;';
                        }
                    });
                };
                
                console.log('Elements to export:', elements.length); // Debug
                console.log('Connections to export:', connections.length); // Debug
                
                // Build GEXF XML structure using the most recent GEXF 1.3 standard
                let gexf = `<?xml version="1.0" encoding="UTF-8"?>\n`;
                gexf += `<gexf xmlns="http://www.gexf.net/1.3" xmlns:viz="http://www.gexf.net/1.3/viz" version="1.3">\n`;
                gexf += `    <meta lastmodifieddate="${new Date().toISOString()}">\n`;
                gexf += `        <creator>Mind Mapper</creator>\n`;
                gexf += `        <description>A mind map export created with Mind Mapper</description>\n`;
                gexf += `        <keywords>mindmap, visualization, graph</keywords>\n`;
                gexf += `    </meta>\n`;
                gexf += `    <graph defaultedgetype="undirected" mode="static">\n`;
                
                // Define node attributes
                gexf += `        <attributes class="node" mode="static">\n`;
                gexf += `            <attribute id="0" title="type" type="string"/>\n`;
                gexf += `            <attribute id="1" title="comment" type="string"/>\n`;
                gexf += `            <attribute id="2" title="fontSize" type="integer"/>\n`;
                gexf += `            <attribute id="3" title="radiusX" type="float"/>\n`;
                gexf += `            <attribute id="4" title="radiusY" type="float"/>\n`;
                gexf += `            <attribute id="5" title="link" type="string"/>\n`;
                gexf += `            <attribute id="6" title="url" type="string"/>\n`;
                gexf += `            <attribute id="7" title="width" type="float"/>\n`;
                gexf += `            <attribute id="8" title="height" type="float"/>\n`;
                gexf += `        </attributes>\n`;
                
                // Define edge attributes
                gexf += `        <attributes class="edge" mode="static">\n`;
                gexf += `            <attribute id="0" title="label" type="string"/>\n`;
                gexf += `        </attributes>\n`;
                
                gexf += `        <nodes>\n`;
                
                // Add all elements as nodes
                elements.forEach(el => {
                    // Handle color conversion with fallback
                    let rgb;
                    try {
                        rgb = hexToRgb(el.color);
                    } catch (error) {
                        console.warn('Invalid color for element:', el.id, 'using default gray');
                        rgb = { r: 150, g: 150, b: 150 };
                    }
                    
                    const size = el.fontSize || parseInt(el.font, 10) || 16;
                    const radiusX = el.radiusX || size;
                    const radiusY = el.radiusY || size;
                    
                    gexf += `            <node id="${el.id}" label="${escapeXML(el.text || el.url || '')}">\n`;
                    gexf += `                <viz:position x="${el.x}" y="${-el.y}" z="0.0"/>\n`;
                    gexf += `                <viz:color r="${rgb.r}" g="${rgb.g}" b="${rgb.b}" a="1.0"/>\n`;
                    gexf += `                <viz:size value="${Math.max(radiusX, radiusY, el.width || 0, el.height || 0)}"/>\n`;
                    gexf += `                <viz:shape value="disc"/>\n`;
                    gexf += `                <attvalues>\n`;
                    gexf += `                    <attvalue for="0" value="${el.type}"/>\n`;
                    if (el.comment) gexf += `                    <attvalue for="1" value="${escapeXML(el.comment)}"/>\n`;
                    gexf += `                    <attvalue for="2" value="${size}"/>\n`;
                    gexf += `                    <attvalue for="3" value="${radiusX}"/>\n`;
                    gexf += `                    <attvalue for="4" value="${radiusY}"/>\n`;
                    gexf += `                    <attvalue for="5" value="${el.link || ''}"/>\n`;
                    if (el.url) gexf += `                    <attvalue for="6" value="${escapeXML(el.url)}"/>\n`;
                    if (el.width) gexf += `                    <attvalue for="7" value="${el.width}"/>\n`;
                    if (el.height) gexf += `                    <attvalue for="8" value="${el.height}"/>\n`;
                    gexf += `                </attvalues>\n`;
                    gexf += `            </node>\n`;
                });
                
                gexf += `        </nodes>\n`;
                gexf += `        <edges>\n`;
                
                // Add all connections as edges
                connections.forEach((conn, i) => {
                    const weight = conn.weight || 1;
                    gexf += `            <edge id="${conn.id}" source="${conn.from}" target="${conn.to}" weight="${weight}">\n`;
                    if (conn.label) {
                        gexf += `                <attvalues>\n`;
                        gexf += `                    <attvalue for="0" value="${escapeXML(conn.label)}"/>\n`;
                        gexf += `                </attvalues>\n`;
                    }
                    gexf += `                <viz:thickness value="${weight}"/>\n`;
                    gexf += `                <viz:color r="128" g="128" b="128" a="0.8"/>\n`;
                    gexf += `            </edge>\n`;
                });
                
                gexf += `        </edges>\n`;
                gexf += `    </graph>\n`;
                gexf += `</gexf>`;
                
                console.log('GEXF content generated, length:', gexf.length); // Debug
                
                // Create and download the file
                const blob = new Blob([gexf], { type: 'application/gexf+xml;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url; 
                a.download = `mindmap_${new Date().toISOString().slice(0,10)}.gexf`;
                document.body.appendChild(a); 
                a.click(); 
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                // Show success message
                console.log('GEXF export completed successfully');
                alert('GEXF file exported successfully!');
                
            } catch (error) {
                console.error('Error during GEXF export:', error);
                alert('Error exporting GEXF file: ' + error.message);
            }
        }

        // Creates a self-contained HTML bundle with embedded mindmap data
        function createBundle() {
            console.log('Creating mindmap bundle...');
            try {
                // Create the mindmap data
                const mindmapData = {
                    elements: elements,
                    connections: connections,
                    scenes: scenes,
                    timestamp: new Date().toISOString(),
                    version: '1.0'
                };
                
                // Convert the data to a JSON string
                const dataString = JSON.stringify(mindmapData, null, 2);
                
                // Base64 encode the data to avoid string literal issues
                const encodedData = btoa(unescape(encodeURIComponent(dataString)));
                
                // Get the current HTML content
                const currentHTML = document.documentElement.outerHTML;
                
                // Create the bundle HTML by inserting the data loading code
                let bundleHTML = currentHTML;
                
                // Find the script tag and insert our data loading code before it
                const scriptTagIndex = bundleHTML.indexOf('<script>');
                if (scriptTagIndex !== -1) {
                    const dataLoadingCode = `
        // --- Embedded Mindmap Data ---
        const embeddedDataEncoded = '${encodedData}';
        
        // Load embedded data on startup
        function loadEmbeddedData() {
            try {
                const decodedData = decodeURIComponent(escape(atob(embeddedDataEncoded)));
                const data = JSON.parse(decodedData);
                if (data && data.elements && data.connections) {
                    console.log('Loading embedded mindmap data...');
                    elements = data.elements;
                    connections = data.connections;
                    if (data.scenes) {
                        scenes = data.scenes;
                        updateScenesList();
                        updateScenesButtons();
                    }
                    
                    // Ensure all connections have IDs
                    connections.forEach(c => { if (!c.id) c.id = Date.now() + Math.random(); });
                    selectedElement = null;
                    
                    // Load any images in the mindmap
                    const imagePromises = elements.filter(el => el.type === 'image').map(el => {
                        return loadImage(el.url).then(img => {
                            // Update natural dimensions if not already set
                            if (!el.naturalWidth || !el.naturalHeight) {
                                el.naturalWidth = img.naturalWidth;
                                el.naturalHeight = img.naturalHeight;
                            }
                        }).catch(error => {
                            console.warn('Failed to load image during bundle load:', el.url, error);
                        });
                    });
                    
                    // Update the title to indicate it's a bundled file
                    document.title = 'Mind Mapper - ' + (data.timestamp ? new Date(data.timestamp).toLocaleDateString() : 'Bundled');
                    
                    console.log('Embedded mindmap loaded successfully');
                    
                    // Draw after images are loaded
                    Promise.all(imagePromises).finally(() => {
                        draw();
                    });
                }
            } catch (error) {
                console.error('Error loading embedded data:', error);
            }
        }
        
        // Call load function after DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', loadEmbeddedData);
        } else {
            loadEmbeddedData();
        }
        
        // --- Original Mindmap Code ---
`;
                    
                    const beforeScript = bundleHTML.substring(0, scriptTagIndex + 8);
                    const afterScript = bundleHTML.substring(scriptTagIndex + 8);
                    bundleHTML = beforeScript + dataLoadingCode + afterScript;
                }
                
                // Create and download the bundle
                const blob = new Blob([bundleHTML], { type: 'text/html;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `mindmap_bundle_${new Date().toISOString().slice(0,10)}.html`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                console.log('Bundle created successfully');
                alert('Mindmap bundle created successfully! This file can be opened directly in any browser and will automatically load your mindmap.');
                
            } catch (error) {
                console.error('Error creating bundle:', error);
                alert('Error creating bundle: ' + error.message);
            }
        }

        // --- Event Listeners for Control Buttons ---
        // Add bubble button - prompts for text and creates bubble at center
        document.getElementById('addBubbleBtn').addEventListener('click', () => {
            const text = prompt("Enter bubble text:", "New Idea");
            if (text) createBubble(text, screenToWorld(canvas.width / 2, canvas.height / 2));
        });
        
        // Add text annotation button - prompts for text and creates annotation at center
        document.getElementById('addTextBtn').addEventListener('click', () => {
            const text = prompt("Enter annotation text:", "Heading");
            if (text) createAnnotation(text, screenToWorld(canvas.width / 2, canvas.height / 2));
        });

        // Add image button - prompts for URL and creates image at center
        document.getElementById('addImageBtn').addEventListener('click', () => {
            const url = prompt("Enter image URL:", "https://example.com/image.jpg");
            if (url) createImage(url, screenToWorld(canvas.width / 2, canvas.height / 2));
        });


        
        // Zoom to fit button - adjusts view to show all content
        document.getElementById('zoomExtentsBtn').addEventListener('click', zoomToExtents);
        
        // Force-directed layout buttons
        document.getElementById('forceLayoutBtn').addEventListener('click', startForceLayout);
        document.getElementById('revertLayoutBtn').addEventListener('click', () => {
            revertToOriginalPositions();
            document.getElementById('revertLayoutBtn').disabled = true;
        });
        
        // Export GEXF button - exports mindmap for external tools
        document.getElementById('exportGexfBtn').addEventListener('click', () => {
            console.log('Export GEXF button clicked'); // Debug
            exportToGEXF();
        });
                
        // Undo/redo buttons
        undoBtn.addEventListener('click', undo);
        redoBtn.addEventListener('click', redo);

        // New button - starts a new mindmap with save prompt if needed
        document.getElementById('newBtn').addEventListener('click', startNewMindmap);

        // Save button - exports mindmap as JSON file
        const saveButton = document.getElementById('saveBtn');
        saveButton.addEventListener('click', () => {
            const data = { elements: elements, connections: connections, scenes: scenes };
            const jsonString = JSON.stringify(data, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url; a.download = 'mindmap.json';
            document.body.appendChild(a); a.click(); document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            // Clear unsaved changes flag after successful save
            clearUnsavedChanges();
            
            // Check if a new mindmap is pending after save
            if (newMindmapPending) {
                newMindmapPending = false;
                // Use setTimeout to ensure the save dialog has closed
                setTimeout(() => {
                    createNewMindmap();
                }, 100);
            }
        });

        // Load button - imports mindmap from JSON file
        const loadFileInput = document.getElementById('loadFile');
        const loadBtn = document.getElementById('loadBtn');
        loadBtn.addEventListener('click', () => loadFileInput.click());
        loadFileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    if (data && data.elements && data.connections) {
                        console.log('Loading mindmap with', data.elements.length, 'elements and', data.connections.length, 'connections');
                        
                        elements = data.elements; 
                        connections = data.connections;
                        if (data.scenes) {
                            scenes = data.scenes;
                            updateScenesList();
                            updateScenesButtons();
                        }
                        
                        // Ensure all connections have IDs
                        connections.forEach(c => { if (!c.id) c.id = Date.now() + Math.random(); });
                        selectedElement = null; 
                        
                        // Load any images in the mindmap
                        const imagePromises = elements.filter(el => el.type === 'image').map(el => {
                            return loadImage(el.url).then(img => {
                                // Update natural dimensions if not already set
                                if (!el.naturalWidth || !el.naturalHeight) {
                                    el.naturalWidth = img.naturalWidth;
                                    el.naturalHeight = img.naturalHeight;
                                }
                            }).catch(error => {
                                console.warn('Failed to load image during mindmap load:', el.url, error);
                            });
                        });
                        
                        // Draw first, then save state
                        draw(); 
                        
                        // Wait for images to load, then save state
                        Promise.all(imagePromises).finally(() => {
                            // Safe save state with error handling
                            try {
                                saveState();
                            } catch (saveError) {
                                console.error('Error saving state after load:', saveError);
                            }
                        });
                        
                        // Ensure canvas has focus after loading for keyboard shortcuts
                        try {
                            canvas.focus();
                            console.log('Mindmap loaded successfully, canvas focused');
                        } catch (focusError) {
                            console.error('Error focusing canvas:', focusError);
                        }
                        
                    } else { 
                        alert('Invalid mind map file.'); 
                    }
                } catch (error) { 
                    console.error('Error loading file:', error);
                    alert('Error loading file: ' + error.message); 
                }
            };
            reader.readAsText(file);
            event.target.value = ''; // Reset file input
        });

        // --- Mouse Event Handlers ---
        // Mouse down handler - handles selection, dragging, and connection creation
        canvas.addEventListener('mousedown', (e) => {
            e.preventDefault();
            hideContextMenu();
            const pos = getEventLocation(e);
            
            // Ensure canvas has focus for keyboard shortcuts
            canvas.focus();
            
            // Middle mouse button - connection creation
            if (e.button === 1) {
                const targetElement = getElementAtPosition(pos.x, pos.y);
                if (connectionStartElement) {
                    // Complete connection if clicking on another bubble
                    if (targetElement && targetElement.type === 'bubble' && targetElement.id !== connectionStartElement.id) {
                        const exists = connections.some(c => (c.from === connectionStartElement.id && c.to === targetElement.id) || (c.from === targetElement.id && c.to === connectionStartElement.id));
                        if (!exists) connections.push({ id: Date.now() + Math.random(), from: connectionStartElement.id, to: targetElement.id, weight: 1 });
                        saveState();
                    }
                    connectionStartElement = null;
                    canvas.classList.remove('connecting');
                    draw();
                } else {
                    // Start connection if clicking on a bubble
                    if (targetElement && targetElement.type === 'bubble') {
                        connectionStartElement = targetElement;
                        canvas.classList.add('connecting');
                        draw();
                    }
                }
                return;
            }
            
            // Left mouse button - selection and dragging
            if (e.button === 0) {
                // Check for resize handle first
                const handle = getResizeHandleAtPosition(pos.x, pos.y);
                if (handle) {
                    resizingElement = selectedElement;
                    resizeHandle = handle;
                    isDragging = true;
                    dragStart = { x: pos.x, y: pos.y };
                    draw();
                    return;
                }
                
                const clickedNode = getElementAtPosition(pos.x, pos.y);
                
                // Check if clicking on image indicators
                if (clickedNode && clickedNode.type === 'image') {
                    const worldPos = screenToWorld(pos.x, pos.y);
                    
                    // Check comment indicator
                    if (clickedNode.comment) {
                        const commentIndicatorX = clickedNode.x + clickedNode.width - 10;
                        const commentIndicatorY = clickedNode.y + 10;
                        const commentDistance = Math.sqrt((worldPos.x - commentIndicatorX) ** 2 + (worldPos.y - commentIndicatorY) ** 2);
                        
                        if (commentDistance <= 5) {
                            // Clicked on comment indicator - show comment
                            let commentText = clickedNode.comment;
                            if (clickedNode.type === 'image') {
                                commentText = `Image: ${clickedNode.url}\n\nComment:\n${clickedNode.comment}`;
                            }
                            document.getElementById('commentDisplay').textContent = commentText;
                            commentModal.style.display = 'flex';
                            return;
                        }
                    }
                    
                    // Check link indicator
                    if (clickedNode.link && clickedNode.link !== clickedNode.url) {
                        const linkIndicatorX = clickedNode.x + clickedNode.width - 10;
                        const linkIndicatorY = clickedNode.y + 20;
                        const linkDistance = Math.sqrt((worldPos.x - linkIndicatorX) ** 2 + (worldPos.y - linkIndicatorY) ** 2);
                        
                        if (linkDistance <= 5) {
                            // Clicked on link indicator - open link
                            window.open(clickedNode.link, '_blank');
                            return;
                        }
                    }
                }
                
                draggedElement = clickedNode;
                selectedElement = clickedNode || getEdgeAtPosition(pos.x, pos.y);
                console.log('Element selected:', selectedElement); // Debug
                isDragging = true;
                dragStart = { x: pos.x, y: pos.y };
                draw();
            }
        });

        // Mouse up handler - finalizes drag operations
        canvas.addEventListener('mouseup', (e) => {
            if (e.button === 0) {
                if (isDragging && (draggedElement || resizingElement)) {
                    saveState();
                }
                isDragging = false; 
                draggedElement = null;
                resizingElement = null;
                resizeHandle = null;
            }
        });

        // Mouse move handler - handles dragging and connection preview
        canvas.addEventListener('mousemove', (e) => {
            lastMousePosition = getEventLocation(e);
            
            // Update connection preview
            if (connectionStartElement) {
                draw();
                return;
            }
            
            // Handle dragging
            if (!isDragging) return;
            const pos = getEventLocation(e);
            const dx = pos.x - dragStart.x; const dy = pos.y - dragStart.y;
            
            if (resizingElement && resizeHandle) {
                // Handle image resizing
                const worldDx = dx / cameraZoom;
                const worldDy = dy / cameraZoom;
                
                // Store original aspect ratio for images
                let originalAspectRatio = null;
                if (resizingElement.type === 'image' && resizingElement.naturalWidth && resizingElement.naturalHeight) {
                    originalAspectRatio = resizingElement.naturalWidth / resizingElement.naturalHeight;
                }
                
                switch (resizeHandle) {
                    case 'top-left':
                        resizingElement.x += worldDx;
                        resizingElement.y += worldDy;
                        resizingElement.width -= worldDx;
                        resizingElement.height -= worldDy;
                        break;
                    case 'top-right':
                        resizingElement.y += worldDy;
                        resizingElement.width += worldDx;
                        resizingElement.height -= worldDy;
                        break;
                    case 'bottom-left':
                        resizingElement.x += worldDx;
                        resizingElement.width -= worldDx;
                        resizingElement.height += worldDy;
                        break;
                    case 'bottom-right':
                        resizingElement.width += worldDx;
                        resizingElement.height += worldDy;
                        break;
                }
                
                // Ensure minimum size
                resizingElement.width = Math.max(50, resizingElement.width);
                resizingElement.height = Math.max(50, resizingElement.height);
                
                // Maintain aspect ratio for images if Shift key is held
                if (originalAspectRatio && e.shiftKey) {
                    const currentAspectRatio = resizingElement.width / resizingElement.height;
                    if (Math.abs(currentAspectRatio - originalAspectRatio) > 0.1) {
                        // Adjust height to match width while maintaining aspect ratio
                        resizingElement.height = resizingElement.width / originalAspectRatio;
                    }
                }
            } else if (draggedElement) {
                // Move element
                draggedElement.x += dx / cameraZoom; draggedElement.y += dy / cameraZoom;
            } else {
                // Pan camera
                cameraOffset.x += dx; cameraOffset.y += dy;
            }
            dragStart = { x: pos.x, y: pos.y };
            draw();
        });

        // Mouse wheel handler - zoom functionality
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const zoomAmount = e.deltaY * SCROLL_SENSITIVITY;
            const mousePos = getEventLocation(e);
            const worldPosBeforeZoom = screenToWorld(mousePos.x, mousePos.y);
            cameraZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, cameraZoom - zoomAmount * cameraZoom));
            const worldPosAfterZoom = screenToWorld(mousePos.x, mousePos.y);
            cameraOffset.x += (worldPosAfterZoom.x - worldPosBeforeZoom.x) * cameraZoom;
            cameraOffset.y += (worldPosAfterZoom.y - worldPosBeforeZoom.y) * cameraZoom;
            draw();
        });

        // Double click handler - text editing and quick bubble creation
        canvas.addEventListener('dblclick', (e) => {
            if (e.button !== 0) return;
            const pos = getEventLocation(e);
            
            // Try to edit existing element
            let targetElement = getElementAtPosition(pos.x, pos.y);
            if (targetElement) {
                if (targetElement.type === 'image') {
                    const newUrl = prompt(`Edit image URL:`, targetElement.url);
                    if (newUrl !== null && newUrl !== targetElement.url) {
                        targetElement.url = newUrl;
                        targetElement.loading = false;
                        
                        // Clear the old image from cache and load the new one
                        imageCache.delete(targetElement.url);
                        
                        // Load the new image and adjust dimensions
                        loadImage(newUrl).then(img => {
                            // Calculate aspect ratio and adjust dimensions
                            const aspectRatio = img.naturalWidth / img.naturalHeight;
                            const maxWidth = 300;
                            const maxHeight = 200;
                            
                            if (aspectRatio > 1) {
                                // Landscape image
                                targetElement.width = maxWidth;
                                targetElement.height = maxWidth / aspectRatio;
                            } else {
                                // Portrait image
                                targetElement.height = maxHeight;
                                targetElement.width = maxHeight * aspectRatio;
                            }
                            
                            targetElement.naturalWidth = img.naturalWidth;
                            targetElement.naturalHeight = img.naturalHeight;
                            
                            draw();
                            saveState();
                        }).catch(error => {
                            console.warn('Could not load new image, keeping current size:', error);
                            draw();
                            saveState();
                        });
                    }
                } else {
                    // Use textarea for multiline editing
                    console.log('Starting bubble edit, original text:', targetElement.text);
                    textInput.value = targetElement.text;
                    textInput.style.display = 'block';
                    
                    // Convert bubble's world position to screen coordinates for proper positioning
                    const screenPos = worldToScreen(targetElement.x, targetElement.y);
                    
                    // Position textarea centered over the bubble
                    const textareaWidth = 200; // Approximate width of textarea
                    const textareaHeight = 100; // Approximate height of textarea
                    textInput.style.left = `${screenPos.x - textareaWidth / 2}px`;
                    textInput.style.top = `${screenPos.y - textareaHeight / 2}px`;
                    textInput.focus();
                    textInput.select();
                    
                    // Store reference to element being edited
                    textInput.dataset.editingElementId = targetElement.id;
                    textInput.dataset.editingElementType = targetElement.type;
                    textInputWorldPosition = null; // Not creating new element
                    console.log('Edit setup complete, editingElementId:', textInput.dataset.editingElementId);
                }
                return;
            }
            
            // Try to edit connection label
            let targetEdge = getEdgeAtPosition(pos.x, pos.y);
            if (targetEdge) {
                const newLabel = prompt('Enter connection label:', targetEdge.label || '');
                if (newLabel !== null) {
                    targetEdge.label = newLabel.trim();
                    draw();
                    saveState();
                }
                return;
            }
            
            // Create new bubble via text input
            textInput.style.display = 'block';
            textInput.style.left = `${pos.x}px`;
            textInput.style.top = `${pos.y}px`;
            textInput.focus();
            textInputWorldPosition = screenToWorld(pos.x, pos.y);
        });
        
        // Right click handler - context menu
        canvas.addEventListener('contextmenu', e => {
            e.preventDefault();
            const pos = getEventLocation(e);
            contextElement = getElementAtPosition(pos.x, pos.y) || getEdgeAtPosition(pos.x, pos.y);
            if (contextElement) {
                selectedElement = contextElement;
                draw();
                const isNode = !!contextElement.id && !contextElement.from;
                
                // Show/hide context menu items based on element type
                document.getElementById('addBubbleContextBtn').style.display = 'none';
                document.getElementById('addAnnotationContextBtn').style.display = 'none';
                document.getElementById('addImageContextBtn').style.display = 'none';
                document.getElementById('elementSeparator').style.display = 'none';
                document.getElementById('growBtn').style.display = 'block';
                document.getElementById('shrinkBtn').style.display = 'block';
                document.getElementById('sizeSeparator').style.display = 'block';
                document.getElementById('commentBtn').style.display = isNode && (contextElement.type === 'bubble' || contextElement.type === 'image') ? 'block' : 'none';
                document.getElementById('viewCommentBtn').style.display = isNode && contextElement.comment ? 'block' : 'none';
                document.getElementById('linkBtn').style.display = isNode && (contextElement.type === 'bubble' || contextElement.type === 'image') ? 'block' : 'none';
                document.getElementById('openLinkBtn').style.display = isNode && contextElement.link ? 'block' : 'none';
                document.getElementById('linkSeparator').style.display = isNode && (contextElement.type === 'bubble' || contextElement.type === 'image') ? 'block' : 'none';
                document.getElementById('deleteBtn').style.display = 'block';
                document.getElementById('deleteSeparator').style.display = 'block';
                
                contextMenu.style.display = 'block';
                contextMenu.style.left = `${e.clientX}px`;
                contextMenu.style.top = `${e.clientY}px`;
            } else { // Right-click on empty canvas
                selectedElement = null;
                draw();
                
                // Store the world position for creating elements
                contextMenu.dataset.worldX = screenToWorld(pos.x, pos.y).x;
                contextMenu.dataset.worldY = screenToWorld(pos.x, pos.y).y;
                
                // Show only add options for empty canvas
                document.getElementById('addBubbleContextBtn').style.display = 'block';
                document.getElementById('addAnnotationContextBtn').style.display = 'block';
                document.getElementById('addImageContextBtn').style.display = 'block';
                document.getElementById('elementSeparator').style.display = 'block';
                document.getElementById('growBtn').style.display = 'none';
                document.getElementById('shrinkBtn').style.display = 'none';
                document.getElementById('sizeSeparator').style.display = 'none';
                document.getElementById('commentBtn').style.display = 'none';
                document.getElementById('viewCommentBtn').style.display = 'none';
                document.getElementById('linkBtn').style.display = 'none';
                document.getElementById('openLinkBtn').style.display = 'none';
                document.getElementById('linkSeparator').style.display = 'none';
                document.getElementById('deleteBtn').style.display = 'none';
                document.getElementById('deleteSeparator').style.display = 'none';
                
                contextMenu.style.display = 'block';
                contextMenu.style.left = `${e.clientX}px`;
                contextMenu.style.top = `${e.clientY}px`;
            }
        });
        
        // Text input handlers for quick bubble creation
        textInput.addEventListener('keydown', (e) => {
            console.log('TextInput keydown event:', e.key, 'shiftKey:', e.shiftKey);
            if (e.key === 'Enter' && !e.shiftKey) {
                console.log('Handling Enter key - blurring textInput');
                e.preventDefault();
                textInput.blur();
            } else if (e.key === 'Enter' && e.shiftKey) {
                // Allow shift+enter for line breaks
                console.log('Handling Shift+Enter - adding line break');
                e.preventDefault();
                const cursorPos = textInput.selectionStart;
                const textBefore = textInput.value.substring(0, cursorPos);
                const textAfter = textInput.value.substring(cursorPos);
                textInput.value = textBefore + '\n' + textAfter;
                textInput.selectionStart = textInput.selectionEnd = cursorPos + 1;
            }
        });

        textInput.addEventListener('blur', () => {
            const text = textInput.value.trim();
            console.log('TextInput blur event, text:', text);
            
            // Check if we're editing an existing element
            const editingElementId = textInput.dataset.editingElementId;
            const editingElementType = textInput.dataset.editingElementType;
            console.log('Editing state:', { editingElementId, editingElementType, textInputWorldPosition });
            
            if (editingElementId && editingElementType) {
                // Find and update the existing element
                // Convert string ID back to number for comparison
                const elementId = parseFloat(editingElementId);
                const element = elements.find(el => el.id === elementId);
                console.log('Found element to edit:', element, 'searching for ID:', elementId);
                if (element) {
                    console.log('Updating element text from:', element.text, 'to:', text);
                    element.text = text;
                    if (element.type === 'bubble') {
                        // Recalculate bubble size for new text
                        const radii = calculateBubbleRadii(text, element.fontSize, element.font);
                        element.radiusX = radii.radiusX;
                        element.radiusY = radii.radiusY;
                        console.log('Bubble resized to:', { radiusX: element.radiusX, radiusY: element.radiusY });
                    }
                    draw();
                    saveState();
                    console.log('Element updated and state saved');
                } else {
                    console.log('ERROR: Element not found for ID:', editingElementId);
                }
                
                // Clear editing state
                delete textInput.dataset.editingElementId;
                delete textInput.dataset.editingElementType;
                console.log('Editing state cleared');
            } else if (text && textInputWorldPosition) {
                // Creating new bubble
                console.log('Creating new bubble with text:', text);
                createBubble(text, textInputWorldPosition);
            } else {
                console.log('No action taken - not editing and not creating new bubble');
            }
            
            textInput.value = '';
            textInput.style.display = 'none';
            textInputWorldPosition = null;
        });

        // --- Context Menu Functions ---
        // Scales an element (grow/shrink)
        function scaleElement(element, change) {
            if (!element) return;
            if (element.type === 'bubble') {
                element.fontSize = Math.max(8, Math.min(100, (element.fontSize || 16) + (change * 2)));
                const radii = calculateBubbleRadii(element.text, element.fontSize);
                element.radiusX = radii.radiusX; element.radiusY = radii.radiusY;
            } else if (element.type === 'text') {
                let currentSize = parseInt(element.font, 10);
                currentSize = Math.max(8, Math.min(100, currentSize + (change * 2)));
                element.font = `${currentSize}px "Open Sans", sans-serif`;
            } else if (element.type === 'image') {
                const scaleFactor = 1 + (change * 0.1);
                element.width = Math.max(50, Math.min(800, element.width * scaleFactor));
                element.height = Math.max(50, Math.min(600, element.height * scaleFactor));
            } else if (element.from && element.to) {
                element.weight = Math.max(1, Math.min(20, (element.weight || 1) + change));
            }
            draw();
            saveState();
        }

        // Context menu button handlers
        document.getElementById('growBtn').addEventListener('click', () => { scaleElement(contextElement, 1); hideContextMenu(); });
        document.getElementById('shrinkBtn').addEventListener('click', () => { scaleElement(contextElement, -1); hideContextMenu(); });

        document.getElementById('addBubbleContextBtn').addEventListener('click', () => {
            const text = prompt("Enter bubble text:", "New Idea");
            if (text) {
                // Use stored world position if available, otherwise use center
                const worldX = parseFloat(contextMenu.dataset.worldX) || screenToWorld(canvas.width / 2, canvas.height / 2).x;
                const worldY = parseFloat(contextMenu.dataset.worldY) || screenToWorld(canvas.width / 2, canvas.height / 2).y;
                createBubble(text, { x: worldX, y: worldY });
            }
            hideContextMenu();
        });

        document.getElementById('addAnnotationContextBtn').addEventListener('click', () => {
            const text = prompt("Enter annotation text:", "Heading");
            if (text) {
                // Use stored world position if available, otherwise use center
                const worldX = parseFloat(contextMenu.dataset.worldX) || screenToWorld(canvas.width / 2, canvas.height / 2).x;
                const worldY = parseFloat(contextMenu.dataset.worldY) || screenToWorld(canvas.width / 2, canvas.height / 2).y;
                createAnnotation(text, { x: worldX, y: worldY });
            }
            hideContextMenu();
        });

        document.getElementById('addImageContextBtn').addEventListener('click', () => {
            const url = prompt("Enter image URL:", "https://example.com/image.jpg");
            if (url) {
                // Use stored world position if available, otherwise use center
                const worldX = parseFloat(contextMenu.dataset.worldX) || screenToWorld(canvas.width / 2, canvas.height / 2).x;
                const worldY = parseFloat(contextMenu.dataset.worldY) || screenToWorld(canvas.width / 2, canvas.height / 2).y;
                createImage(url, { x: worldX, y: worldY });
            }
            hideContextMenu();
        });

        document.getElementById('commentBtn').addEventListener('click', () => {
            if (contextElement) {
                const newComment = prompt('Enter comment:', contextElement.comment || '');
                if (newComment !== null) {
                    contextElement.comment = newComment.trim();
                    if (!contextElement.comment) delete contextElement.comment;
                    draw();
                    saveState();
                }
            }
            hideContextMenu();
        });

        document.getElementById('viewCommentBtn').addEventListener('click', () => {
            if (contextElement && contextElement.comment) {
                let commentText = contextElement.comment;
                
                // For images, add some context about the image
                if (contextElement.type === 'image') {
                    commentText = `Image: ${contextElement.url}\n\nComment:\n${contextElement.comment}`;
                }
                
                document.getElementById('commentDisplay').textContent = commentText;
                commentModal.style.display = 'flex';
            }
            hideContextMenu();
        });

        document.getElementById('linkBtn').addEventListener('click', () => {
            if (contextElement) {
                if (contextElement.type === 'image') {
                    // For images, ask if user wants to change the image source or just the link
                    const choice = confirm('Do you want to change the image source? Click OK to change the image, Cancel to just change the clickable link.');
                    
                    if (choice) {
                        // Change the image source
                        const newUrl = prompt('Enter new image URL:', contextElement.url);
                        if (newUrl !== null && newUrl !== contextElement.url) {
                            contextElement.url = newUrl;
                            contextElement.loading = false;
                            
                            // Clear the old image from cache and load the new one
                            imageCache.delete(contextElement.url);
                            
                            // Load the new image and adjust dimensions
                            loadImage(newUrl).then(img => {
                                // Calculate aspect ratio and adjust dimensions
                                const aspectRatio = img.naturalWidth / img.naturalHeight;
                                const maxWidth = 300;
                                const maxHeight = 200;
                                
                                if (aspectRatio > 1) {
                                    // Landscape image
                                    contextElement.width = maxWidth;
                                    contextElement.height = maxWidth / aspectRatio;
                                } else {
                                    // Portrait image
                                    contextElement.height = maxHeight;
                                    contextElement.width = maxHeight * aspectRatio;
                                }
                                
                                contextElement.naturalWidth = img.naturalWidth;
                                contextElement.naturalHeight = img.naturalHeight;
                                
                                draw();
                                saveState();
                            }).catch(error => {
                                console.warn('Could not load new image, keeping current size:', error);
                                draw();
                                saveState();
                            });
                        }
                    } else {
                        // Just change the clickable link
                        const defaultLink = contextElement.link || contextElement.url;
                        const newLink = prompt('Enter clickable link URL:', defaultLink);
                        if (newLink !== null) {
                            contextElement.link = newLink.trim();
                            if (!contextElement.link) delete contextElement.link;
                            draw();
                            saveState();
                        }
                    }
                } else {
                    // For non-image elements, just change the link
                    const newLink = prompt('Enter URL:', contextElement.link || '');
                    if (newLink !== null) {
                        contextElement.link = newLink.trim();
                        if (!contextElement.link) delete contextElement.link;
                        draw();
                        saveState();
                    }
                }
            }
            hideContextMenu();
        });

        document.getElementById('openLinkBtn').addEventListener('click', () => {
            if (contextElement && contextElement.link) {
                window.open(contextElement.link, '_blank');
            }
            hideContextMenu();
        });

        document.getElementById('deleteBtn').addEventListener('click', () => {
            deleteElement(contextElement);
            hideContextMenu();
        });

        // --- Color Palette Handler ---
        document.getElementById('colorPalette').addEventListener('click', (e) => {
            if (e.target.classList.contains('color-swatch')) {
                const newColor = e.target.dataset.color;
                nextBubbleColor = newColor;
                document.querySelectorAll('.color-swatch').forEach(sw => sw.classList.remove('selected'));
                e.target.classList.add('selected');
                if (selectedElement && selectedElement.type === 'bubble') {
                    selectedElement.color = newColor;
                    draw();
                    saveState();
                }
            }
        });
        
        // --- Modal Handlers ---
        document.getElementById('helpBtn').addEventListener('click', () => helpModal.style.display = 'flex');
        document.querySelectorAll('.close-modal-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                helpModal.style.display = 'none';
                commentModal.style.display = 'none';
            });
        });
        helpModal.addEventListener('click', (e) => { if (e.target === helpModal) helpModal.style.display = 'none'; });
        commentModal.addEventListener('click', (e) => { if (e.target === commentModal) commentModal.style.display = 'none'; });

        // Hide context menu when clicking outside
        window.addEventListener('click', (e) => { if (!contextMenu.contains(e.target)) hideContextMenu(); });

        // --- Keyboard Shortcuts ---
        // Add keyboard listener to canvas for better focus handling
        canvas.addEventListener('keydown', (e) => {
            console.log('Canvas keydown:', e.key, 'selectedElement:', selectedElement, 'canvas focused:', document.activeElement === canvas); // Debug
            const isCmdOrCtrl = e.metaKey || e.ctrlKey;

            // Undo/Redo
            if (isCmdOrCtrl && e.key.toLowerCase() === 'z') { e.preventDefault(); undo();
            } else if (isCmdOrCtrl && e.key.toLowerCase() === 'y') { e.preventDefault(); redo();
            // Save
            } else if (isCmdOrCtrl && e.key.toLowerCase() === 's') { e.preventDefault(); saveButton.click();
            // Copy/Paste
            } else if (isCmdOrCtrl && e.key.toLowerCase() === 'c') { if (selectedElement) clipboard = JSON.parse(JSON.stringify(selectedElement));
            } else if (isCmdOrCtrl && e.key.toLowerCase() === 'v') {
                if (clipboard) {
                    const newElement = JSON.parse(JSON.stringify(clipboard));
                    newElement.id = Date.now() + Math.random();
                    if (newElement.from) { // It's a connection
                        const fromExists = elements.some(el => el.id === newElement.from);
                        const toExists = elements.some(el => el.id === newElement.to);
                        if (fromExists && toExists) {
                            connections.push(newElement);
                            selectedElement = newElement;
                        }
                    } else { // It's a node
                        newElement.x += 20 / cameraZoom; newElement.y += 20 / cameraZoom;
                        elements.push(newElement); 
                        selectedElement = newElement;
                    }
                    draw(); 
                    saveState();
                }
            // Delete
            } else if (e.key === 'Delete' || e.key === 'Backspace') {
                deleteElement(selectedElement);
            // Quick add bubble
            } else if (e.key.toLowerCase() === 'b') {
                const text = prompt("Enter new bubble text:", "New Idea");
                if (text) createBubble(text, screenToWorld(canvas.width / 2, canvas.height / 2));
            // Quick add annotation
            } else if (e.key.toLowerCase() === 'a') {
                const text = prompt("Enter new annotation text:", "Heading");
                if (text) createAnnotation(text, screenToWorld(canvas.width / 2, canvas.height / 2));
            // Quick add image
            } else if (e.key.toLowerCase() === 'i') {
                const url = prompt("Enter image URL:", "https://example.com/image.jpg");
                if (url) createImage(url, screenToWorld(canvas.width / 2, canvas.height / 2));
            // Zoom to fit
            } else if (e.key.toLowerCase() === 'z' && !isCmdOrCtrl) {
                zoomToExtents();
            // Scale selected element
            } else if (e.key === '=' || e.key === '+' || e.key === '-') {
                console.log('Scale key pressed:', e.key, 'selectedElement:', selectedElement, 'elements array length:', elements.length); // Debug
                if (selectedElement) {
                    const change = (e.key === '-') ? -1 : 1;
                    console.log('Calling scaleElement with change:', change, 'element type:', selectedElement.type); // Debug
                    scaleElement(selectedElement, change);
                } else {
                    console.log('No selectedElement found - try clicking on an element first'); // Debug
                }
            // Scene navigation
            } else if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                if (scenes.length > 0) {
                    if (e.key === 'ArrowUp') {
                        const newIndex = currentSceneIndex > 0 ? currentSceneIndex - 1 : scenes.length - 1;
                        selectScene(newIndex);
                    } else {
                        const newIndex = currentSceneIndex < scenes.length - 1 ? currentSceneIndex + 1 : 0;
                        selectScene(newIndex);
                    }
                }
            // Element nudging
            } else if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                if (selectedElement && !selectedElement.from) { // Only nudge elements, not connections
                    const nudgeAmount = 10 / cameraZoom; // Nudge by 10 pixels in world coordinates
                    if (e.key === 'ArrowLeft') {
                        selectedElement.x -= nudgeAmount;
                    } else {
                        selectedElement.x += nudgeAmount;
                    }
                    draw();
                    saveState();
                }
            }
        });

        // Also keep the window listener as fallback
        window.addEventListener('keydown', (e) => {
            // Allow keyboard shortcuts when canvas or body is the target
            if (e.target !== document.body && e.target !== canvas) return;
            const isCmdOrCtrl = e.metaKey || e.ctrlKey;

            // Undo/Redo
            if (isCmdOrCtrl && e.key.toLowerCase() === 'z') { e.preventDefault(); undo();
            } else if (isCmdOrCtrl && e.key.toLowerCase() === 'y') { e.preventDefault(); redo();
            // Save
            } else if (isCmdOrCtrl && e.key.toLowerCase() === 's') { e.preventDefault(); saveButton.click();
            // Copy/Paste
            } else if (isCmdOrCtrl && e.key.toLowerCase() === 'c') { if (selectedElement) clipboard = JSON.parse(JSON.stringify(selectedElement));
            } else if (isCmdOrCtrl && e.key.toLowerCase() === 'v') {
                if (clipboard) {
                    const newElement = JSON.parse(JSON.stringify(clipboard));
                    newElement.id = Date.now() + Math.random();
                    if (newElement.from) { // It's a connection
                        const fromExists = elements.some(el => el.id === newElement.from);
                        const toExists = elements.some(el => el.id === newElement.to);
                        if (fromExists && toExists) {
                            connections.push(newElement);
                            selectedElement = newElement;
                        }
                    } else { // It's a node
                        newElement.x += 20 / cameraZoom; newElement.y += 20 / cameraZoom;
                        elements.push(newElement); 
                        selectedElement = newElement;
                    }
                    draw(); 
                    saveState();
                }
            // Delete
            } else if (e.key === 'Delete' || e.key === 'Backspace') {
                deleteElement(selectedElement);
            // Quick add bubble
            } else if (e.key.toLowerCase() === 'b') {
                const text = prompt("Enter new bubble text:", "New Idea");
                if (text) createBubble(text, screenToWorld(canvas.width / 2, canvas.height / 2));
            // Quick add annotation
            } else if (e.key.toLowerCase() === 'a') {
                const text = prompt("Enter new annotation text:", "Heading");
                if (text) createAnnotation(text, screenToWorld(canvas.width / 2, canvas.height / 2));
            // Quick add image
            } else if (e.key.toLowerCase() === 'i') {
                const url = prompt("Enter image URL:", "https://example.com/image.jpg");
                if (url) createImage(url, screenToWorld(canvas.width / 2, canvas.height / 2));
            // Zoom to fit
            } else if (e.key.toLowerCase() === 'z' && !isCmdOrCtrl) {
                zoomToExtents();
            // Scale selected element
            } else if (e.key === '=' || e.key === '+' || e.key === '-') {
                if (selectedElement) {
                    const change = (e.key === '-') ? -1 : 1;
                    scaleElement(selectedElement, change);
                }
            // Scene navigation
            } else if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                if (scenes.length > 0) {
                    if (e.key === 'ArrowUp') {
                        const newIndex = currentSceneIndex > 0 ? currentSceneIndex - 1 : scenes.length - 1;
                        selectScene(newIndex);
                    } else {
                        const newIndex = currentSceneIndex < scenes.length - 1 ? currentSceneIndex + 1 : 0;
                        selectScene(newIndex);
                    }
                }
            // Element nudging
            } else if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                if (selectedElement && !selectedElement.from) { // Only nudge elements, not connections
                    const nudgeAmount = 10 / cameraZoom; // Nudge by 10 pixels in world coordinates
                    if (e.key === 'ArrowLeft') {
                        selectedElement.x -= nudgeAmount;
                    } else {
                        selectedElement.x += nudgeAmount;
                    }
                    draw();
                    saveState();
                }
            }
        });
        
        // --- Window Event Handlers ---
        window.addEventListener('resize', setup);
        
        // --- Initialization ---
        const loadingIndicator = document.getElementById('loadingIndicator');
        document.fonts.ready.then(() => {
            loadingIndicator.style.display = 'none';
            setup();
        });

        // Bundle button - creates a self-contained HTML bundle
        document.getElementById('bundleBtn').addEventListener('click', () => {
            createBundle();
        });

        // Scene management button handlers
        document.getElementById('addSceneBtn').addEventListener('click', () => {
            createScene();
        });

        document.getElementById('removeSceneBtn').addEventListener('click', () => {
            if (currentSceneIndex >= 0) {
                removeScene(currentSceneIndex);
            }
        });

        document.getElementById('playScenesBtn').addEventListener('click', () => {
            if (isPlayingScenes) {
                stopPlayingScenes();
                document.getElementById('playScenesBtn').textContent = '‚ñ∂Ô∏è Play';
            } else {
                playScenes();
                document.getElementById('playScenesBtn').textContent = '‚èπÔ∏è Stop';
            }
        });

        // Toggle scenes panel expand/collapse
        document.getElementById('toggleScenesBtn').addEventListener('click', () => {
            const panel = document.getElementById('scenesPanel');
            const toggleBtn = document.getElementById('toggleScenesBtn');
            
            if (panel.classList.contains('collapsed')) {
                panel.classList.remove('collapsed');
                toggleBtn.textContent = '‚ñº';
                toggleBtn.title = 'Collapse scenes panel';
            } else {
                panel.classList.add('collapsed');
                toggleBtn.textContent = '‚ñ≤';
                toggleBtn.title = 'Expand scenes panel';
            }
        });

        // Large play/stop button handlers
        document.getElementById('largePlayBtn').addEventListener('click', () => {
            playScenes();
        });

        document.getElementById('largeStopBtn').addEventListener('click', () => {
            stopPlayingScenes();
        });
    </script>


</body></html>